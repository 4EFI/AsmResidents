Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 1
main.asm



      1
      2				     .286
      3	0000			     .model tiny
      4	0000			     .code
      5				     org 100h
      6
      7				     locals __
      8
      9				     include		 TOOLS.ASM				 ; Exit
1    10
1    11				     ;------------------------------------------------
1    12				     ;	     EXIT PROGRAM
1    13				     ;------------------------------------------------
1    14				     ; Entry:	     NONE
1    15				     ; EXIT:	     NONE
1    16				     ; DESTROYS: AX
1    17				     ;------------------------------------------------
1    18
1    19				     EXIT	     macro
1    20							     nop
1    21							     mov ax, 4c00h
1    22							     int 21h
1    23							     nop
1    24							     endm
1    25
1    26				     ;------------------------------------------------
     27
     28				     ;------------------------------------------------
     29
     30	0100  33 DB		     Start:	     xor bx, bx			 ; ES =	0
     31	0102  8E C3				     mov es, bx
     32
     33	0104  BB 0020				     mov bx, 4d	* 8d		 ; BX =	4*8 ( 8th Intr - Timer )
     34
     35	0107  FA				     cli			 ; START NO-INTR
     36
     37	0108  26: 8B 07				     mov ax, es:[bx]		 ; Old_08_Ofs =	0:[4*8]
     38	010B  A3 0181r				     mov Old_08_Ofs, ax
     39
     40	010E  26: C7 07	014Br			     mov es:[bx], offset New08	 ; 0:[4*8] = New_Intr_Func_Ofs
     41
     42	0113  26: 8B 47	02			     mov ax, es:[bx + 2]	 ; Old_08_Seg =	0:[4*8 + 2]
     43	0117  A3 0183r				     mov Old_08_Seg, ax
     44
     45	011A  8C C8				     mov ax, cs
     46	011C  26: 89 47	02			     mov es:[bx	+ 2], ax	 ; 0:[4*8 + 2] = New_Intr_Func_Seg
     47
     48	0120  FB				     sti			 ; END NO-INTR
     49
     50	0121  BB 0024				     mov bx, 4d	* 9d		 ; BX =	4*9 ( 9th Intr - Keyboard )
     51
     52	0124  FA				     cli			 ; START NO-INTR
     53
     54	0125  26: 8B 07				     mov ax, es:[bx]		 ; Old_09_Ofs =	0:[4*9]
     55	0128  A3 01B9r				     mov Old_09_Ofs, ax
     56
     57	012B  26: C7 07	0186r			     mov es:[bx], offset New09	 ; 0:[4*9] = New_Intr_Func_Ofs
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 2
main.asm



     58
     59	0130  26: 8B 47	02			     mov ax, es:[bx + 2]	 ; Old_09_Seg =	0:[4*9 + 2]
     60	0134  A3 01BBr				     mov Old_09_Seg, ax
     61
     62	0137  8C C8				     mov ax, cs
     63	0139  26: 89 47	02			     mov es:[bx	+ 2], ax	 ; 0:[4*9 + 2] = New_Intr_Func_Seg
     64
     65	013D  FB				     sti			 ; END NO-INTR
     66
     67	013E  B8 3100				     mov ax, 3100h		 ; EXIT	with saving
     68	0141  BA 0684r				     mov dx, offset EOP
     69	0144  C1 EA 04				     shr dx, 4
     70	0147  42				     inc dx
     71	0148  CD 21				     int 21h
     72
     73				     ;------------------------------------------------
     74
     75				     include	 NEW_RESD.ASM	 ; Resident programs
1    76
1    77	014A  00		     IsPrintReg	     db	 0
1    78
1    79	      =0002		     X_Pos = 2
1    80
1    81	014B			     New08	     proc
1    82
1    83	014B  50 53 51 52			     push ax bx	cx dx
1    84	014F  56 06				     push si es
1    85
1    86	0151  BE 0022				     mov  si, 4*8 + 2		  ; ES = CurrProgSeg
1    87	0154  8B 1C				     mov  bx, [si]
1    88	0156  86 FB				     xchg bh, bl
1    89	0158  8E C3				     mov  es, bx
1    90	015A  BB 014Ar				     mov  bx, offset IsPrintReg
1    91	015D  26: 80 3F	00			     cmp  byte ptr es:[bx], 0
1    92	0161  74 17				     je	__End
1    93
1    94	0163  53				     push bx			 ; save	BX
1    95
1    96	0164  BB B800				     mov  bx, 0b800h		 ; ES =	VideoSeg
1    97	0167  8E C3				     mov  es, bx
1    98
1    99	0169  B7 00				     mov  bh, 0			 ; (X; Y) = (0;	0)
1   100	016B  B3 00				     mov  bl, 0
1   101	016D  E8 0502				     call PrintNum		 ; print AX
1   102
1   103	0170  5B				     pop  bx			 ; load	BX
1   104	0171  8B C3				     mov  ax, bx		 ; AX =	BX
1   105	0173  B7 00				     mov  bh, 0			 ; (X; Y) = (0;	1)
1   106	0175  B3 01				     mov  bl, 1
1   107	0177  E8 04F8				     call PrintNum		 ; print BX
1   108
1   109	017A					     __End:
1   110
1   111	017A  07 5E				     pop es si
1   112	017C  5A 59 5B 58			     pop dx cx bx ax
1   113
1   114	0180  EA				     db	0eah			 ; jmp Old_08_Seg:[Old_08_Ofs]
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 3
main.asm



1   115	0181  0000				     Old_08_Ofs	dw 0
1   116	0183  0000				     Old_08_Seg	dw 0
1   117
1   118	0185  CF				     iret
1   119	0186					     endp
1   120
1   121	0186			     New09	     proc
1   122
1   123	0186  50				     push ax			 ; save	AX
1   124	0187  E4 60				     in	  al, 60h		 ; get scan key
1   125	0189  3C 3B				     cmp  al, 3bh		 ; F1 =	print regs
1   126	018B  74 03				     je	__PrintRegs
1   127
1   128	018D  EB 28 90				     jmp __NoPrintRegs
1   129
1   130	0190					     __PrintRegs:
1   131
1   132	0190  53 56 06				     push bx si	es
1   133	0193  BE 0026				     mov  si, 4*9 + 2		  ; ES = CurrProgSeg
1   134	0196  8B 1C				     mov  bx, [si]
1   135	0198  86 FB				     xchg bh, bl
1   136	019A  8E C3				     mov  es, bx
1   137	019C  BB 014Ar				     mov  bx, offset IsPrintReg
1   138	019F  80 36 0002 01			     xor byte ptr X_Pos, 1	       ; On/Off	flag
**Error** NEW_RESD.ASM(63) Illegal immediate
1   139	01A4  07 5E 5B				     pop  es si	bx
1   140
1   141	01A7  E4 61				     in	 al, 61h		 ; Signal keyboard
1   142	01A9  0C 80				     or	 al, 80h
1   143	01AB  E6 61				     out 61h, al
1   144	01AD  24 7F				     and al, not 80h
1   145	01AF  E6 61				     out 61h, al
1   146
1   147	01B1  B0 20				     mov al, 20h		 ; End-of-Intr
1   148	01B3  E6 20				     out 20h, al
1   149
1   150	01B5  58				     pop ax			 ; load	AX
1   151	01B6  CF				     iret
1   152
1   153	01B7					     __NoPrintRegs:
1   154
1   155	01B7  58				     pop  ax			 ; losd	AX
1   156
1   157	01B8  EA				     db	0eah			 ; jmp Old_09_Seg:[Old_09_Ofs]
1   158	01B9  0000				     Old_09_Ofs	dw 0
1   159	01BB  0000				     Old_09_Seg	dw 0
1   160
1   161	01BD  CF				     iret
1   162	01BE					     endp
1   163
    164				     include	     SCR_HNDL.ASM    ; Clear screen function
1   165
1   166				     ; SCREEN HANDLER
1   167
1   168				     ;------------------------------------------------
1   169				     ;	     FILL SCREEN BY SYM
1   170				     ;	     FROM ( X; Y ) to (	X + WIDTH; Y + HEIGHT )
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 4
main.asm



1   171				     ;------------------------------------------------
1   172				     ; ENTRY:	     AH	= COLOR	ATTR
1   173				     ;			     AL	= SYM
1   174				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   175				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   176				     ;			     CH	= WIDTH
1   177				     ;			     CL	= HEIGHT
1   178				     ; EXIT:	     NONE
1   179				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   180				     ; DESTROYS:     NONE
1   181				     ;------------------------------------------------
1   182
1   183	01BE			     FillScreen		     proc
1   184
1   185	01BE  53						     push bx			     ; push (1)
1   186	01BF  51						     push cx			     ; push (2)
1   187	01C0  52						     push dx			     ; push (3)
1   188
1   189	01C1  50						     push ax			     ; push (4)
1   190	01C2  E8 0035						     call GetVideoPos
1   191	01C5  8B D8						     mov bx, ax
1   192	01C7  58						     pop ax			     ; pop  (4)
1   193
1   194	01C8  8A F5						     __NextLine:		     mov dh, ch		     ; i =  +
    195				     CH
1   196
1   197	01CA  53											     push bx		    +
    198				     ; push (5)
1   199
1   200	01CB  26: 89 07											     __Next:		    +
    201				     mov es:[bx], ax
1   202	01CE  83 C3 02														    +
    203				     add bx, 2
1   204
1   205	01D1  FE CE														    +
    206				     dec dh		     ; i--
1   207
1   208	01D3  80 FE 00														    +
    209				     cmp dh, 0d		     ; if( dh == 0 )
1   210	01D6  74 02														    +
    211				     je	__End
1   212
1   213	01D8  EB F1														    +
    214				     jmp __Next
1   215	01DA												     __End:
1   216
1   217	01DA  5B											     pop bx		    +
    218				     ; pop  (5)
1   219
1   220	01DB  81 C3 00A0										     add bx, 160d    ; BX +=+
    221				     2*80
1   222
1   223	01DF  FE C9											     dec cl		    +
    224				     ; CL--
1   225
1   226	01E1  80 F9 00											     cmp cl, 0d	     ; if(  +
    227				     CL	== 0 )
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 5
main.asm



1   228	01E4  74 02											     je	__EndNextLine
1   229
1   230	01E6  EB E0											     jmp __NextLine
1   231	01E8							     __EndNextLine:
1   232
1   233	01E8  5A						     pop dx			     ; pop  (3)
1   234	01E9  59						     pop cx			     ; pop  (2)
1   235	01EA  5B						     pop bx			     ; pop  (1)
1   236
1   237	01EB  C3						     ret
1   238	01EC							     endp
1   239
1   240				     ;------------------------------------------------
1   241				     ;	     CLEAR SCREEN BY SYM
1   242				     ;------------------------------------------------
1   243				     ; ENTRY:	     AH	= COLOR	ATTR
1   244				     ;			     AL	= SYM
1   245				     ; EXIT:	     NONE
1   246				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   247				     ; DESTROYS:     NONE
1   248				     ;------------------------------------------------
1   249
1   250	01EC			     ClrScreen		     proc
1   251
1   252	01EC  53						     push bx			     ; push (1)
1   253	01ED  51						     push cx			     ; push (2)
1   254
1   255	01EE  33 DB						     xor bx, bx			     ; X = 0; Y	= 0
1   256	01F0  B5 50						     mov ch, 80d
1   257	01F2  B1 19						     mov cl, 25d
1   258	01F4  E8 FFC7						     call FillScreen
1   259
1   260	01F7  59						     pop cx			     ; pop  (2)
1   261	01F8  5B						     pop bx			     ; pop  (1)
1   262
1   263	01F9  C3						     ret
1   264	01FA							     endp
1   265
1   266				     ;------------------------------------------------
1   267				     ;	     GET VIDEO POS FROM	(X; Y)
1   268				     ;------------------------------------------------
1   269				     ; ENTRY:	     BH	= X LEFT CORNER	COORDS [0; 79]
1   270				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   271				     ; EXIT:	     AX	= POS
1   272				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   273				     ; DESTROYS:     AX
1   274				     ;------------------------------------------------
1   275
1   276	01FA			     GetVideoPos	     proc
1   277
1   278	01FA  D0 E7						     shl bh, 1		     ; bh /= 2
1   279
1   280	01FC  52						     push dx		     ; push (1)
1   281
1   282	01FD  B0 A0						     mov al, 160d    ; ax = 160	* Y + 2	* X
1   283	01FF  F6 E3						     mul bl
1   284	0201  BA 0000						     mov dx, 0
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 6
main.asm



1   285	0204  02 D7						     add dl, bh
1   286	0206  03 C2						     add ax, dx
1   287
1   288	0208  5A						     pop dx		     ; pop  (1)
1   289
1   290	0209  D0 EF						     shr bh, 1		     ; bh *= 2
1   291
1   292	020B  C3						     ret
1   293	020C							     endp
1   294
1   295				     ;------------------------------------------------
1   296				     ;	     PRINT SYM IN (X; Y)
1   297				     ;------------------------------------------------
1   298				     ; ENTRY:	     AH	= SYM COLOR
1   299				     ;			     AL	= SYM CHAR
1   300				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   301				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   302				     ; EXIT:	     NONE
1   303				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   304				     ; DESTROYS:     NONE
1   305				     ;------------------------------------------------
1   306
1   307	020C			     PrintChar		     proc
1   308
1   309	020C  57						     push di		     ; push (1)
1   310	020D  50						     push ax		     ; push (2)
1   311
1   312	020E  E8 FFE9						     call GetVideoPos
1   313
1   314	0211  8B F8						     mov di, ax		     ; print( ax )
1   315	0213  58						     pop ax		     ; pop  (2)
1   316	0214  AB						     stosw
1   317
1   318	0215  5F						     pop di		     ; pop  (1)
1   319
1   320	0216  C3						     ret
1   321	0217							     endp
1   322
1   323				     ;------------------------------------------------
1   324				     ;	     PRINT STR IN (X; Y)
1   325				     ;------------------------------------------------
1   326				     ; ENTRY:	     AH	= SYM COLOR
1   327				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   328				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   329				     ;			     CX	= STR ADDR
1   330				     ; EXIT:	     NONE
1   331				     ; EXPECTS:	     ES	     = 0b800h (VIDEO SEGMENT)
1   332				     ;			     END SYM = '\0' || '$' || '\r'
1   333				     ; DESTROYS:     NONE
1   334				     ;------------------------------------------------
1   335
1   336	0217			     PrintStr		     proc
1   337
1   338	0217  50						     push ax		     ; push (1)
1   339	0218  53						     push bx		     ; push (2)
1   340	0219  52						     push dx		     ; push (3)
1   341	021A  56						     push si		     ; push (4)
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 7
main.asm



1   342
1   343	021B  8B F1						     mov si, cx		     ; SI = StrAddr
1   344
1   345	021D  8A 14						     __Next:		     mov dl, [si]    ; DX = CurrSym
1   346
1   347	021F  80 FA 00										     cmp dl, 0d		     ; if(  +
    348				     DL	== 0 )
1   349	0222  74 14										     je	__End
1   350	0224  80 FA 0D										     cmp dl, 13d	     ; if(  +
    351				     DL	== '\r'	)
1   352	0227  74 0F										     je	__End
1   353	0229  80 FA 24										     cmp dl, '$'	     ; if(  +
    354				     DL	== '$' )
1   355	022C  74 0A										     je	__End
1   356
1   357	022E  8A 04										     mov al, [si]    ; AL = CurrSym
1   358	0230  E8 FFD9										     call PrintChar
1   359
1   360	0233  FE C7										     inc bh		     ; X++
1   361	0235  46										     inc si		     ;	    +
    362				     CurrSymPos++
1   363
1   364	0236  E2 E5										     loop __Next
1   365	0238							     __End:
1   366
1   367	0238  5E						     pop si		     ; pop  (4)
1   368	0239  5A						     pop dx		     ; pop  (3)
1   369	023A  58						     pop ax		     ; pop  (2)
1   370	023B  5B						     pop bx		     ; pop  (1)
1   371
1   372	023C  C3						     ret
1   373	023D							     endp
1   374
1   375				     ;------------------------------------------------
1   376				     ;	     PRINT HORIZONTAL LINE IN (X; Y)
1   377				     ;------------------------------------------------
1   378				     ; ENTRY:	     AH	= SYM COLOR
1   379				     ;			     AL	= SYM CHAR
1   380				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   381				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   382				     ;			     CH	= WIDTH
1   383				     ;			     DH	= LEFT	SYM
1   384				     ;			     DL	= RIGHT	SYM
1   385				     ; EXIT:	     NONE
1   386				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   387				     ; DESTROYS:     NONE
1   388				     ;------------------------------------------------
1   389
1   390	023D			     PrintHrzLine    proc
1   391
1   392	023D  80 FD 01						     cmp ch, 1			     ; if( ch <= 1 ) ret
1   393	0240  76 37						     jbe __End
1   394
1   395	0242  53						     push bx			     ; push (1)
1   396	0243  52						     push dx			     ; push (2)
1   397
1   398
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 8
main.asm



1   399	0244  50						     push ax			     ; push (3)
1   400	0245  8A C6						     mov al, dh			     ; printf( "%c", LeftSym )
1   401	0247  E8 FFC2						     call PrintChar
1   402	024A  58						     pop ax			     ; pop  (3)
1   403
1   404	024B  50						     push ax			     ; push (4)
1   405	024C  53						     push bx			     ; push (5)
1   406	024D  02 FD						     add bh, ch			     ; X += ( WIDTH - 1	)
1   407	024F  80 EF 01						     sub bh, 1
1   408	0252  8A C2						     mov al, dl			     ; printf( "%c", RightSym )
1   409	0254  E8 FFB5						     call PrintChar
1   410	0257  5B						     pop bx			     ; pop  (5)
1   411	0258  58						     pop ax			     ; pop  (4)
1   412
1   413	0259  53						     push bx			     ; push (6)
1   414	025A  51						     push cx			     ; push (7)
1   415
1   416	025B  80 C7 01						     add bh, 1			     ; X += 1
1   417	025E  80 ED 02						     sub ch, 2			     ; WIDTH -=	2
1   418
1   419	0261  80 FD 00						     cmp ch, 0			     ; if( ch == 0 )
1   420	0264  74 0F						     je	     __EndPrinting
1   421
1   422	0266  33 D2						     xor dx, dx			     ; i = 0
1   423
1   424	0268  E8 FFA1						     __Next:		     call PrintChar
1   425
1   426	026B  FE C7										     inc bh
1   427	026D  FE C6										     inc dh
1   428
1   429	026F  3A F5										     cmp dh, ch
1   430	0271  74 02										     je	 __EndPrinting
1   431
1   432	0273  EB F3										     jmp __Next
1   433
1   434	0275							     __EndPrinting:
1   435
1   436	0275  59						     pop cx			     ; pop  (7)
1   437	0276  5B						     pop bx			     ; pop  (6)
1   438
1   439
1   440	0277  5A						     pop dx			     ; pop  (2)
1   441	0278  5B						     pop bx			     ; pop  (1)
1   442
1   443	0279							     __End:
1   444	0279  C3						     ret
1   445	027A							     endp
1   446
1   447				     ;------------------------------------------------
1   448				     ;	     PRINT VERTICAL LINE IN (X;	Y)
1   449				     ;------------------------------------------------
1   450				     ; ENTRY:	     AH	= SYM COLOR
1   451				     ;			     AL	= SYM CHAR
1   452				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   453				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   454				     ;			     CL	= HEIGHT
1   455				     ;			     DH	= TOP  SYM
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 9
main.asm



1   456				     ;			     DL	= DOWN SYM
1   457				     ; EXIT:	     NONE
1   458				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   459				     ; DESTROYS:     NONE
1   460				     ;------------------------------------------------
1   461
1   462	027A			     PrintVrtLine    proc
1   463
1   464	027A  80 F9 01						     cmp cl, 1			     ; if( cl <= 1 ) ret
1   465	027D  76 37						     jbe __End
1   466
1   467	027F  53						     push bx			     ; push (1)
1   468	0280  52						     push dx			     ; push (2)
1   469
1   470
1   471	0281  50						     push ax			     ; push (3)
1   472	0282  8A C6						     mov al, dh			     ; printf( "%c", TopSym )
1   473	0284  E8 FF85						     call PrintChar
1   474	0287  58						     pop ax			     ; pop  (3)
1   475
1   476	0288  50						     push ax			     ; push (4)
1   477	0289  53						     push bx			     ; push (5)
1   478	028A  02 D9						     add bl, cl			     ; Y += ( HEIGHT - 1 )
1   479	028C  80 EB 01						     sub bl, 1
1   480	028F  8A C2						     mov al, dl			     ; printf( "%c", DownSym )
1   481	0291  E8 FF78						     call PrintChar
1   482	0294  5B						     pop bx			     ; pop  (5)
1   483	0295  58						     pop ax			     ; pop  (4)
1   484
1   485	0296  53						     push bx			     ; push (6)
1   486	0297  51						     push cx			     ; push (7)
1   487
1   488	0298  80 C3 01						     add bl, 1			     ; Y += 1
1   489	029B  80 E9 02						     sub cl, 2			     ; HEIGHT -= 2
1   490
1   491	029E  80 F9 00						     cmp cl, 0			     ; if( cl == 0 )
1   492	02A1  74 0F						     je	     __EndPrinting
1   493
1   494	02A3  33 D2						     xor dx, dx			     ; i = 0
1   495
1   496	02A5  E8 FF64						     __Next:		     call PrintChar
1   497
1   498	02A8  FE C3										     inc bl
1   499	02AA  FE C2										     inc dl
1   500
1   501	02AC  3A D1										     cmp dl, cl
1   502	02AE  74 02										     je	 __EndPrinting
1   503
1   504	02B0  EB F3										     jmp __Next
1   505
1   506	02B2							     __EndPrinting:
1   507
1   508	02B2  59						     pop cx			     ; pop  (7)
1   509	02B3  5B						     pop bx			     ; pop  (6)
1   510
1   511
1   512	02B4  5A						     pop dx			     ; pop  (2)
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 10
main.asm



1   513	02B5  5B						     pop bx			     ; pop  (1)
1   514
1   515	02B6							     __End:
1   516	02B6  C3						     ret
1   517	02B7							     endp
1   518
1   519				     ;------------------------------------------------
1   520				     ;	     PRINT BOX
1   521				     ;------------------------------------------------
1   522				     ; ENTRY:	     AX	= STR  ADDR
1   523				     ;			     BX	= DATA ADDR
1   524				     ; EXIT:	     NONE
1   525				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   526				     ; DESTROYS:     NONE
1   527				     ;------------------------------------------------
1   528
1   529				     ; User's type
1   530	02B7  09*(00)		     Type_0  db		     9 dup (0)
1   531
1   532				     ; Template	types
1   533				     ;				     0		     1		     2		     3		    +
    534				     4		     5		     6		     7		     9
1   535				     ;				     lt		     ld		     rt		     rd		    +
    536				     lv		     rv		     th		     dh		     fill
1   537	02C0  C9 C8 BB BC BA BA	CD+  Type_1  db		     0c9h,   0c8h,   0bbh,   0bch,   0bah,   0bah,   0cdh,   0cdh,   0d
    538	      CD 00
1   539	02C9  03 03 03 03 03 03	03+  Type_2  db		     003h,   003h,   003h,   003h,   003h,   003h,   003h,   003h,   '-'
    540	      03 2D
1   541	02D2  BC BB C8 C9 CD CD	BA+  Type_3  db		     0bch,   0bbh,   0c8h,   0c9h,   0cdh,   0cdh,   0bah,   0bah,   0d
    542	      BA 00
1   543	02DB  DA C0 BF D9 B3 B3	C4+  Type_4  db		     0dah,   0c0h,   0bfh,   0d9h,   0b3h,   0b3h,   0c4h,   0c4h,   0d
    544	      C4 00
1   545
1   546	      =0000		     X_Num    =	0
1   547	      =0001		     Y_Num    =	1
1   548	      =0002		     W_Num    =	2
1   549	      =0003		     H_Num    =	3
1   550	      =0004		     Clr_Num  =	4
1   551	      =0005		     Type_Num =	5
1   552
1   553	02E4			     PrintBox		     proc
1   554
1   555	02E4  50						     push ax				     ; push (1)
1   556	02E5  53						     push bx				     ; push (2)
1   557	02E6  51						     push cx				     ; push (3)
1   558	02E7  52						     push dx				     ; push (4)
1   559	02E8  56						     push si				     ; push (5)
1   560	02E9  57						     push di				     ; push (6)
1   561	02EA  55						     push bp				     ; push (7)
1   562
1   563	02EB  50						     push ax				     ; push (8)	<> push	STR +
    564				     ADDR
1   565
1   566	02EC  8B F3						     mov si, bx				     ; SI = DATA ADDR( BX )
1   567
1   568								     ; SET TYPE	BOX
1   569
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 11
main.asm



1   570	02EE  33 C0						     xor ax, ax				     ; BP = Type_0 + Type * 9
1   571	02F0  8A 47 05						     mov al, bx[Type_Num]
1   572	02F3  B9 0009						     mov cx, 9d
1   573	02F6  F7 E1						     mul cx
1   574	02F8  8B E8						     mov bp, ax
1   575	02FA  81 C5 02B7r					     add bp, offset Type_0
1   576
1   577	02FE  8A 67 04						     mov ah, bx[Clr_Num]	     ; AH = Color
1   578
1   579	0301  8A 6F 02						     mov ch, bx[W_Num]		     ; CH = WIDTH
1   580	0304  8A 4F 03						     mov cl, bx[H_Num]		     ; CL = HEIGHT
1   581
1   582								     ; PRINT TOP HORIZONTAL LINE
1   583
1   584	0307  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
1   585	0309  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   586	030C  8A 46 06						     mov  al, bp[6]		     ; AL = horizontal sym
1   587	030F  8A 76 00						     mov  dh, bp[0]		     ; DH = left  top  sym
1   588	0312  8A 56 02						     mov  dl, bp[2]		     ; DL = right top  sym
1   589	0315  E8 FF25						     call PrintHrzLine
1   590
1   591								     ; PRINT LEFT VERTICAL LINE
1   592
1   593	0318  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
1   594	031A  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   595	031D  8A 46 04						     mov  al, bp[4]		     ; AL = vertical  sym
1   596	0320  8A 76 00						     mov  dh, bp[0]		     ; DH = left top  sym
1   597	0323  8A 56 01						     mov  dl, bp[1]		     ; DL = left down sym
1   598	0326  E8 FF51						     call PrintVrtLine
1   599
1   600	0329  53						     push bx				     ; push (9)	<> push	(X; +
    601				     Y)
1   602
1   603								     ; PRINT DOWN HORIZONTAL LINE
1   604
1   605	032A  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
1   606	032C  8A 54 01						     mov  dl, si[Y_Num]		 ; Y +=	( HEIGHT - 1 )
1   607	032F  02 D1						     add  dl, cl
1   608	0331  80 EA 01						     sub  dl, 1
1   609	0334  8A DA						     mov  bl, dl			     ; BL = Y
1   610	0336  8A 46 07						     mov  al, bp[7]		     ; AL = horizontal sym
1   611	0339  8A 76 01						     mov  dh, bp[1]		     ; DH = left  down sym
1   612	033C  8A 56 03						     mov  dl, bp[3]		     ; DL = right down sym
1   613	033F  E8 FEFB						     call PrintHrzLine
1   614
1   615								     ; PRINT RIGHT VERTICAL LINE
1   616
1   617	0342  8A 14						     mov  dl, si[X_Num]		 ; X +=	( WIDTH	- 1 )
1   618	0344  02 D5						     add  dl, ch
1   619	0346  80 EA 01						     sub  dl, 1
1   620	0349  8A FA						     mov  bh, dl			     ; BH = X
1   621	034B  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   622	034E  8A 46 05						     mov  al, bp[5]		     ; AL = vertical   sym
1   623	0351  8A 76 02						     mov  dh, bp[2]		     ; DH = right top  sym
1   624	0354  8A 56 03						     mov  dl, bp[3]		     ; DL = right down sym
1   625	0357  E8 FF20						     call PrintVrtLine
1   626
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 12
main.asm



1   627								     ; FILL BOX
1   628
1   629	035A  53						     push bx				     ; push (10)
1   630	035B  51						     push cx				     ; push (11)
1   631	035C  8A 3C						     mov  bh, si[X_Num]		     ; BH = X +	1
1   632	035E  80 C7 01						     add  bh, 1
1   633	0361  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y +	1
1   634	0364  80 C3 01						     add  bl, 1
1   635	0367  8A 46 08						     mov  al, bp[8]		     ; AL = filling sym
1   636	036A  80 ED 02						     sub  ch, 2				     ; WIDTH  -= 2
1   637	036D  80 E9 02						     sub  cl, 2				     ; HEIGHT -= 2
1   638	0370  E8 FE4B						     call FillScreen
1   639	0373  59						     pop  cx				     ; pop  (11)
1   640	0374  5B						     pop  bx				     ; pop  (10)
1   641
1   642	0375  5B						     pop  bx				     ; pop  (9)	<> pop (X; Y)
1   643	0376  58						     pop  ax				     ; pop  (8)	<> pop STR  +
    644				     ADDR
1   645
1   646								     ; PRINT STR
1   647
1   648	0377  8B C8						     mov  cx, ax			     ; CX = STR	ADDR
1   649	0379  8B D8						     mov  bx, ax			     ; BX = STR	ADDR
1   650	037B  E8 012C						     call StrLen			     ; AX = len	of str
1   651	037E  F7 D8						     neg  ax				     ; AX = ( WIDTH - LEN ) +
    652				     / 2
1   653	0380  33 D2						     xor  dx, dx
1   654	0382  8A 54 02						     mov  dl, si[W_Num]
1   655	0385  03 C2						     add  ax, dx
1   656	0387  33 D2						     xor  dx, dx
1   657	0389  BD 0002						     mov  bp, 2d
1   658	038C  F7 F5						     div  bp
1   659	038E  8A 3C						     mov  bh, si[X_Num]		     ; X += AL
1   660	0390  02 F8						     add  bh, al
1   661	0392  33 C0						     xor  ax, ax			     ; AX = HEIGHT / 2
1   662	0394  8A 44 03						     mov  al, si[H_Num]
1   663	0397  33 D2						     xor  dx, dx
1   664	0399  BD 0002						     mov  bp, 2d
1   665	039C  F7 F5						     div  bp
1   666	039E  8A 5C 01						     mov  bl, si[Y_Num]		     ; Y += AL
1   667	03A1  02 D8						     add  bl, al
1   668	03A3  8A 64 04						     mov  ah, si[Clr_Num]    ; AH = color
1   669	03A6  E8 FE6E						     call PrintStr
1   670
1   671	03A9  5D						     pop bp				     ; pop  (7)
1   672	03AA  5F						     pop di				     ; pop  (6)
1   673	03AB  5E						     pop si				     ; pop  (5)
1   674	03AC  5A						     pop dx				     ; pop  (4)
1   675	03AD  59						     pop cx				     ; pop  (3)
1   676	03AE  5B						     pop bx				     ; pop  (2)
1   677	03AF  58						     pop ax				     ; pop  (1)
1   678
1   679	03B0  C3						     ret
1   680	03B1							     endp
1   681
1   682				     ;------------------------------------------------
1   683				     ;	     ANIMATE BOX
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 13
main.asm



1   684				     ;------------------------------------------------
1   685				     ; ENTRY:	     AX	= STR  ADDR
1   686				     ;			     BX	= DATA ADDR
1   687				     ; EXIT:	     NONE
1   688				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   689				     ; DESTROYS:     NONE
1   690				     ;------------------------------------------------
1   691
1   692	03B1  00		     EmptyStr db	     0
1   693	03B2  14*(00)		     BoxData  db     20	dup (0)
1   694
1   695	03C6			     AnimBox		     proc
1   696
1   697	03C6  53						     push bx		     ; push (1)
1   698	03C7  51						     push cx		     ; push (2)
1   699	03C8  52						     push dx		     ; push (3)
1   700
1   701	03C9  8B CB						     mov  cx, bx
1   702	03CB  BB 03B2r						     mov  bx, offset BoxData
1   703	03CE  BA 0014						     mov  dx, 20d
1   704	03D1  E8 0130						     call memcpy
1   705
1   706	03D4  33 C9						     xor  cx, cx	     ; i = 0
1   707
1   708	03D6  8A 36 03B4r					     mov  dh, BoxData[W_Num]
1   709	03DA  8A 16 03B5r					     mov  dl, BoxData[H_Num]
1   710
1   711	03DE  C6 06 03B4r 03					     mov  BoxData[W_Num], 3d
1   712	03E3  C6 06 03B5r 03					     mov  BoxData[H_Num], 3d
1   713
1   714	03E8  50						     push ax		     ; push (4)
1   715	03E9  B8 03B1r						     mov  ax, offset EmptyStr
1   716
1   717	03EC  E8 FEF5						     __Next:		     call PrintBox
1   718
1   719	03EF  38 36 03B4r									     cmp byte ptr BoxData[W_Num], dh+
    720				     ; if( CURR_WIDTH == WIDTH )
1   721	03F3  74 04										     je	__NoIncW
1   722	03F5  FE 06 03B4r									     inc BoxData[W_Num]
1   723
1   724	03F9											     __NoIncW:
1   725
1   726	03F9  38 16 03B5r									     cmp byte ptr BoxData[H_Num], dl+
    727				     ; if( CURR_HEIGHT == HEIGHT )
1   728	03FD  74 04										     je	__NoIncH
1   729	03FF  FE 06 03B5r									     inc BoxData[H_Num]
1   730
1   731	0403											     __NoIncH:
1   732
1   733	0403  41										     inc cx			    +
    734				     ; i++
1   735
1   736	0404  83 F9 11										     cmp cx, 17d
1   737	0407  74 0D										     je	__End
1   738
1   739	0409  50										     push ax			    +
    740				     ; push (5)
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 14
main.asm



1   741	040A  51										     push cx			    +
    742				     ; push (6)
1   743	040B  B4 86										     mov  ah, 86h
1   744	040D  B9 0001										     mov  cx, 1d
1   745	0410  CD 15										     int  15h
1   746	0412  59										     pop  cx			    +
    747				     ; pop  (6)
1   748	0413  58										     pop  ax			    +
    749				     ; pop  (5)
1   750
1   751	0414  EB D6										     jmp __Next
1   752
1   753	0416							     __End:
1   754	0416  58						     pop ax		     ; pop  (4)
1   755
1   756	0417  88 36 03B4r					     mov BoxData[W_Num], dh
1   757	041B  88 16 03B5r					     mov BoxData[H_Num], dl
1   758
1   759	041F  E8 FEC2						     call PrintBox
1   760
1   761	0422  5A						     pop dx		     ; pop  (3)
1   762	0423  59						     pop cx		     ; pop  (2)
1   763	0424  5B						     pop bx		     ; pop  (1)
1   764
1   765	0425  C3						     ret
1   766	0426							     endp
1   767
1   768				     ;------------------------------------------------
1   769				     ;	     INPUT STR
1   770				     ;------------------------------------------------
1   771				     ; ENTRY:	     NONE
1   772				     ; EXIT:	     AX	= STR LEN
1   773				     ; DESTROYS:     AX
1   774				     ;------------------------------------------------
1   775
1   776	      =0064		     InputLen =	100
1   777	0426  64*(00)		     InputStr db     InputLen dup (0)
1   778
1   779	048A			     Input		     proc
1   780
1   781	048A  52						     push dx		     ; push (1)
1   782	048B  33 D2						     xor  dx, dx	     ; i = 0
1   783
1   784	048D  B4 01						     __Next:		     mov ah, 01h			    +
    785				     ; input char
1   786	048F  CD 21										     int 21h
1   787
1   788	0491  56										     push si			    +
    789				     ; push (2)
1   790
1   791	0492  33 F6										     xor si, si			    +
    792				     ; SI = 0
1   793
1   794	0494  BE 0426r										     mov si, offset InputStr	    +
    795				     ; SI = InputStr + DX
1   796	0497  03 F2										     add si, dx
1   797
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 15
main.asm



1   798	0499  88 04										     mov [si], al
1   799
1   800	049B  5E										     pop si			    +
    801				     ; pop  (2)
1   802
1   803	049C  3C 0D										     cmp al, 13d		    +
    804				     ; if( al == '\r' )
1   805	049E  74 06										     je	__End
1   806
1   807	04A0  42										     inc dx			    +
    808				     ; i++
1   809	04A1  83 FA 64										     cmp dx, InputLen		    +
    810				     ; if( i ==	InputLen )
1   811	04A4  75 E7										     jne __Next
1   812
1   813	04A6							     __End:
1   814
1   815	04A6  8B C2						     mov ax, dx
1   816	04A8  5A						     pop dx		     ; pop  (1)
1   817
1   818	04A9  C3						     ret
1   819	04AA							     endp
1   820
1   821				     ;------------------------------------------------
1   822
    823				     include	     STR_HNDL.ASM    ; Str handler
1   824
1   825				     ;------------------------------------------------
1   826				     ;	     GET STR LEN
1   827				     ;------------------------------------------------
1   828				     ; ENTRY:	     BX	= STR ADDR
1   829				     ; EXIT:	     AX	= LEN
1   830				     ; EXPECTS:	 END SYM = '\0'
1   831				     ; DESTROYS: AX
1   832				     ;------------------------------------------------
1   833
1   834	04AA			     StrLen	     proc
1   835
1   836	04AA  33 C0				     xor ax, ax	     ; i = 0
1   837
1   838	04AC  51 56						     push cx si		     ; push (1)	(2)
1   839
1   840	04AE  8B F3				     __Next:		     mov  si, bx     ; SI = BX + i
1   841	04B0  03 F0										 add  si, ax
1   842
1   843	04B2  40										     inc  ax		     ; i++
1   844	04B3  8B 0C										     mov  cx, [si]   ; CX = current +
    845				     symbol
1   846
1   847	04B5  80 FD 00										     cmp  ch, 0d     ; if( ch ==    +
    848				     '\0' )
1   849	04B8  74 02										     je	__End
1   850
1   851	04BA  EB F2										     jmp __Next
1   852
1   853	04BC							     __End:
1   854	04BC  5E 59						     pop si cx		     ; pop  (2)	(1)
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 16
main.asm



1   855
1   856	04BE  C3				     ret
1   857	04BF					     endp
1   858
1   859				     ;------------------------------------------------
1   860				     ;	     GET ADDR OF CHR IN	ARR
1   861				     ;	     RET NULL IF NOT FOUND
1   862				     ;------------------------------------------------
1   863				     ; ENTRY:	     BX	= ARR ADDR
1   864				     ;			     CL	= CHR
1   865				     ;			     DX	= LEN OF THE COMPARED PART (IN BYTES)
1   866				     ; EXIT:	     AX	= ADDR OF CHR
1   867				     ; DESTROYS: AX
1   868				     ;------------------------------------------------
1   869
1   870	04BF			     MemChr		     proc
1   871
1   872	04BF  56						     push si		     ; push (1)
1   873
1   874	04C0  33 C0						     xor ax, ax		     ; AX = NULL
1   875	04C2  33 F6						     xor si, si		     ; i  = 0
1   876
1   877	04C4  83 FA 00						     cmp dx, 0d		     ; if( len == 0 )
1   878	04C7  74 0F						     je	__End
1   879
1   880	04C9  38 08						     __Next:		     cmp bx[si], cl	     ; if( Addr[i]  +
    881				     ==	CHR )
1   882	04CB  74 07										     je	__Found
1   883
1   884	04CD  46										     inc si
1   885
1   886	04CE  3B F2										     cmp si, dx
1   887	04D0  74 06										     je	__End
1   888
1   889	04D2  EB F5										     jmp __Next
1   890
1   891	04D4  8B C3						     __Found:		     mov ax, bx			     ; AX = +
    892				     ArrAddr + i
1   893	04D6  03 C6										     add ax, si
1   894
1   895	04D8							     __End:
1   896	04D8  5E						     pop si		     ; pop  (1)
1   897
1   898	04D9  C3						     ret
1   899	04DA							     endp
1   900
1   901				     ;------------------------------------------------
1   902				     ;	     GET ADDR OF CHR IN	STR
1   903				     ;	     RET NULL IF NOT FOUND
1   904				     ;------------------------------------------------
1   905				     ; ENTRY:	     BX	= ARR ADDR
1   906				     ;			     CL	= CHR
1   907				     ; EXIT:	     AX	= ADDR OF CHR
1   908				     ; EXPECTS:	 END SYM = '\0'
1   909				     ; DESTROYS: AX
1   910				     ;------------------------------------------------
1   911
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 17
main.asm



1   912	04DA			     StrChr		     proc
1   913
1   914	04DA  56						     push si		     ; push (1)
1   915
1   916	04DB  33 C0						     xor ax, ax		     ; AX = NULL
1   917	04DD  33 F6						     xor si, si		     ; i  = 0
1   918
1   919	04DF  38 08						     __Next:		     cmp byte ptr bx[si], cl	     ; if(  +
    920				     Addr[i] ==	CHR )
1   921	04E1  74 08										     je	__Found
1   922	04E3  80 38 00										     cmp byte ptr bx[si], 0d	    +
    923				     ; if( Addr[i] == '\0' )
1   924	04E6  74 07										     je	__End
1   925
1   926	04E8  46										     inc si
1   927
1   928	04E9  EB F4										     jmp __Next
1   929
1   930	04EB  8B C3						     __Found:		     mov ax, bx				    +
    931				     ; AX = ArrAddr + i
1   932	04ED  03 C6										     add ax, si
1   933
1   934	04EF							     __End:
1   935	04EF  5E						     pop si		     ; pop  (1)
1   936
1   937	04F0  C3						     ret
1   938	04F1							     endp
1   939
1   940				     ;------------------------------------------------
1   941				     ;	     THE MEMSET	FUNCTION FILLS
1   942				     ;	     THE FIRST N BYTES OF THE MEMORY
1   943				     ;	     LOCATION POINTED TO BY THE
1   944				     ;	     DESTINATION ARGUMENT WITH THE
1   945				     ;	     CHARACTER SPECIFIED BY THE	CHR ARGUMENT
1   946				     ;------------------------------------------------
1   947				     ; ENTRY:	     BX	= DESTINATION
1   948				     ;			     CL	= CHR
1   949				     ;			     DX	= N
1   950				     ; EXIT:	     NONE
1   951				     ; DESTROYS: NONE
1   952				     ;------------------------------------------------
1   953
1   954	04F1			     MemSet		     proc
1   955
1   956	04F1  56						     push si		     ; push (1)
1   957
1   958	04F2  33 F6						     xor si, si		     ; i = 0
1   959
1   960	04F4  83 FA 00						     cmp dx, 0d		     ; if( N ==	0 )
1   961	04F7  74 09						     je	__End
1   962
1   963	04F9  88 08						     __Next:		     mov byte ptr bx[si], cl	     ; BX[i]+
    964				     = CHR
1   965
1   966	04FB  46										     inc si			    +
    967				     ; i++
1   968
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 18
main.asm



1   969	04FC  3B F2										     cmp si, dx			    +
    970				     ; if( i ==	N )
1   971	04FE  74 02										     je	__End
1   972
1   973	0500  EB F7										     jmp __Next
1   974	0502							     __End:
1   975	0502  5E						     pop     si			     ; pop  (1)
1   976
1   977	0503  C3						     ret
1   978	0504							     endp
1   979
1   980				     ;------------------------------------------------
1   981				     ;	     THE MEMCPY	FUNCTION COPIES	N BYTES
1   982				     ;	     FROM THE ARRAY (SOURCE) TO	THE ARRAY
1   983				     ;	     (DESTINATION). IF THE ARRAYS OVERLAP,
1   984				     ;	     THE RESULT	OF THE COPY WILL BE UNDEFINED
1   985				     ;------------------------------------------------
1   986				     ; ENTRY:	     BX	= DESTINATION
1   987				     ;			     CX	= SOURCE
1   988				     ;			     DX	= N
1   989				     ; EXIT:	     NONE
1   990				     ; DESTROYS: NONE
1   991				     ;------------------------------------------------
1   992
1   993	0504			     MemCpy		     proc
1   994
1   995	0504  56 55						     push si bp		     ; push (1)	(2)
1   996
1   997	0506  8B E9						     mov bp, cx		     ; BP = CX
1   998
1   999	0508  33 F6						     xor si, si		     ; i = 0
1  1000
1  1001	050A  83 FA 00						     cmp dx, 0		     ; if( N ==	0 )
1  1002	050D  74 0D						     je	__End
1  1003
1  1004	050F  52						     __Next:		     push dx				    +
   1005				     ; push (3)
1  1006	0510  8A 12										     mov  dl, bp[si]
1  1007	0512  88 10										     mov  byte ptr bx[si], dl	    +
   1008				     ; BX[i] = CX[i]
1  1009	0514  5A										     pop  dx			    +
   1010				     ; pop  (3)
1  1011
1  1012	0515  46										     inc si			    +
   1013				     ; i++
1  1014
1  1015	0516  3B F2										     cmp si, dx			    +
   1016				     ; if( N ==	i )
1  1017	0518  74 02										     je	__End
1  1018
1  1019	051A  EB F3										     jmp __Next
1  1020
1  1021	051C							     __End:
1  1022	051C  5D 5E						     pop bp si		     ; pop  (2)	(1)
1  1023
1  1024	051E  C3						     ret
1  1025	051F							     endp
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 19
main.asm



1  1026
1  1027				     ;------------------------------------------------
1  1028				     ;	     THE STRCPY	FUNCTION COPIES	THE DATA FROM
1  1029				     ;	     THE SOURCE	ARGUMENT TO THE	DESTINATION
1  1030				     ;	     UNTIL THE END-OF-LINE( NULL ) CHARACTER
1  1031				     ;	     IS	ENCOUNTERED.
1  1032				     ;	     COPYING IS	DONE ALONG WITH	THE
1  1033				     ;	     END-OF-LINE CHARACTER
1  1034				     ;------------------------------------------------
1  1035				     ; ENTRY:	     BX	= DESTINATION
1  1036				     ;			     CX	= SOURCE
1  1037				     ; EXIT:	     NONE
1  1038				     ; DESTROYS: NONE
1  1039				     ;------------------------------------------------
1  1040
1  1041	051F			     StrCpy		     proc
1  1042
1  1043	051F  52 56 55						     push dx si	bp   ; push (1)	(2) (3)
1  1044
1  1045	0522  8B E9						     mov bp, cx		     ; BP = CX
1  1046
1  1047	0524  33 F6						     xor si, si		     ; i = 0
1  1048
1  1049	0526  8A 12						     __Next:		     mov dl, bp[si]
1  1050	0528  88 10										     mov byte ptr bx[si], dl	    +
   1051				     ; BX[i] = CX[i]
1  1052
1  1053	052A  80 3A 00										     cmp byte ptr bp[si], 0d	    +
   1054				     ; if( CX[i] == 0 )
1  1055	052D  74 03										     je	__End
1  1056
1  1057	052F  46										     inc si			    +
   1058				     ; i++
1  1059
1  1060	0530  EB F4										     jmp __Next
1  1061
1  1062	0532							     __End:
1  1063	0532  5D 5E 5A						     pop bp si dx    ; pop  (3)	(2) (1)
1  1064
1  1065	0535  C3						     ret
1  1066	0536							     endp
1  1067
1  1068				     ;------------------------------------------------
1  1069				     ;	     THE MEMCMP	FUNCTION COMPARES, BYTE	BY BYTE,
1  1070				     ;	     THE TWO ARRAYS ARR_1 AND ARR_2.
1  1071				     ;	     THE COMPARISON CONTINUES UNTIL N BYTES
1  1072				     ;	     HAVE BEEN CHECKED OR UNTIL	DIFFERENT
1  1073				     ;	     BYTES ARE ENCOUNTERED.
1  1074				     ;------------------------------------------------
1  1075				     ; ENTRY:	     BX	= ARR_1
1  1076				     ;			     CX	= ARR_2
1  1077				     ;			     DX	= N
1  1078				     ; EXIT:	     AX	= 0 ( ARR_1[i] == ARR_2[i] : FOR i in [0; N-1] )
1  1079				     ;			     AX	> 0 ( ARR_1[i] >  ARR_2[i] )
1  1080				     ;			     AX	< 0 ( ARR_1[i] <  ARR_2[i] )
1  1081				     ; DESTROYS: AX
1  1082				     ;------------------------------------------------
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 20
main.asm



1  1083
1  1084	0536			     MemCmp		     proc
1  1085
1  1086	0536  56 55						     push si bp		     ; push (1)	(2)
1  1087
1  1088	0538  8B E9						     mov bp, cx		     ; BP = CX
1  1089
1  1090	053A  33 F6						     xor si, si		     ; i  = 0
1  1091
1  1092	053C  83 FA 00						     cmp dx, 0d		     ; if( N ==	0 )
1  1093	053F  74 18						     je	__End
1  1094
1  1095	0541  33 C0						     __Next:		     xor  ax, ax			    +
   1096				     ; AX  = 0
1  1097	0543  8A 00										     mov  al, bx[si]		    +
   1098				     ; AL  = BX[i]
1  1099	0545  52										     push dx			    +
   1100				     ; push (3)
1  1101	0546  33 D2										     xor  dx, dx		    +
   1102				     ; DX = 0
1  1103	0548  8A 12										     mov  dl, bp[si]
1  1104	054A  2B C2										     sub  ax, dx		    +
   1105				     ; AX -= CX[i]
1  1106	054C  5A										     pop  dx			    +
   1107				     ; pop  (3)
1  1108
1  1109	054D  3D 0000										     cmp ax, 0d			    +
   1110				     ; if( AX != 0 )
1  1111	0550  75 07										     jne __End
1  1112
1  1113	0552  46										     inc si
1  1114
1  1115	0553  3B F2										     cmp si, dx			    +
   1116				     ; if( i ==	N )
1  1117	0555  74 02										     je	__End
1  1118
1  1119	0557  EB E8										     jmp __Next
1  1120	0559							     __End:
1  1121	0559  5D 5E						     pop bp si		     ; pop  (2)	(1)
1  1122
1  1123	055B  C3						     ret
1  1124	055C							     endp
1  1125
1  1126				     ;------------------------------------------------
1  1127				     ;	     THE MEMCMP	FUNCTION COMPARES, BYTE	BY BYTE,
1  1128				     ;	     THE TWO STRINGS STR_1 AND STR_2.
1  1129				     ;	     THE COMPARISON CONTINUES UNTIL THE
1  1130				     ;	     END-OF-LINE( NULL ) OR UNTIL DIFFERENT
1  1131				     ;	     BYTES ARE ENCOUNTERED.
1  1132				     ;------------------------------------------------
1  1133				     ; ENTRY:	     BX	= STR_1
1  1134				     ;			     CX	= STR_2
1  1135				     ; EXIT:	     AX	= 0 ( STR_1[i] == STR_2[i] : FOR ALL i )
1  1136				     ;			     AX	> 0 ( STR_1[i] >  STR_2[i] )
1  1137				     ;			     AX	< 0 ( STR_1[i] <  STR_2[i] )
1  1138				     ; DESTROYS: AX
1  1139				     ;------------------------------------------------
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 21
main.asm



1  1140
1  1141	055C			     StrCmp		     proc
1  1142
1  1143	055C  56 55						     push si bp		     ; push (1)	(2)
1  1144
1  1145	055E  8B E9						     mov bp, cx		     ; BP = CX
1  1146
1  1147	0560  33 F6						     xor si, si		     ; i  = 0
1  1148
1  1149	0562  33 C0						     __Next:		     xor  ax, ax			    +
   1150				     ; AX  = 0
1  1151	0564  8A 00										     mov  al, bx[si]		    +
   1152				     ; AL  = BX[i]
1  1153	0566  52										     push dx			    +
   1154				     ; push (3)
1  1155	0567  33 D2										     xor  dx, dx		    +
   1156				     ; DX = 0
1  1157	0569  8A 12										     mov  dl, bp[si]
1  1158	056B  2B C2										     sub  ax, dx		    +
   1159				     ; AX -= CX[i]
1  1160	056D  5A										     pop  dx			    +
   1161				     ; pop  (3)
1  1162
1  1163	056E  3D 0000										     cmp ax, 0d			    +
   1164				     ; if( AX != 0 )
1  1165	0571  75 08										     jne __End
1  1166
1  1167	0573  80 38 00										     cmp byte ptr bx[si], 0d	    +
   1168				     ; if( BX[i] == 0 )
1  1169	0576  74 03										     je	__End
1  1170
1  1171	0578  46										     inc si
1  1172
1  1173	0579  EB E7										     jmp __Next
1  1174	057B							     __End:
1  1175	057B  5D 5E						     pop bp si		     ; pop  (2)	(1)
1  1176
1  1177	057D  C3						     ret
1  1178	057E							     endp
1  1179
1  1180				     ;------------------------------------------------
1  1181				     ;	     TRANSLATE STR TO NUMBER
1  1182				     ;------------------------------------------------
1  1183				     ; ENTRY:	     BX	= STR ADDR
1  1184				     ; EXIT:	     AX	= NUM
1  1185				     ; EXPECTS:	     CX	= STR LEN
1  1186				     ; DESTROYS:     AX
1  1187				     ;------------------------------------------------
1  1188
1  1189	057E			     Atoi		     proc
1  1190
1  1191	057E  33 C0						     xor ax, ax		     ; AX = 0
1  1192
1  1193	0580  52 56						     push dx si		     ; push (1)	(2)
1  1194
1  1195	0582  33 D2						     xor dx, dx		     ; i = 0
1  1196
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 22
main.asm



1  1197	0584  8B F3						     __Next:		     mov si, bx		     ; SI = BX +    +
   1198				     STR_LEN - i
1  1199	0586  03 F1										     add si, cx
1  1200	0588  2B F2										     sub si, dx
1  1201	058A  83 EE 01										     sub si, 1
1  1202
1  1203	058D  51										     push cx		     ; push +
   1204				     (3)
1  1205
1  1206	058E  50										     push ax		     ; push +
   1207				     (4)
1  1208	058F  33 C0										     xor  ax, ax     ; AX = 0
1  1209	0591  8A 04										     mov  al, [si]   ; AX = [SI] -  +
   1210				     '0'
1  1211	0593  2C 30										     sub  al, 48d
1  1212
1  1213	0595  52										     push dx		     ; push +
   1214				     (5)
1  1215	0596  8B CA										     mov  cx, dx	     ; AX = +
   1216				     AX	* 10^DX
1  1217	0598  BE 000A										     mov  si, 10d
1  1218	059B  E3 08										     jcxz __NoMul
1  1219
1  1220	059D  F7 E6										     __Mul:		     mul si
1  1221
1  1222	059F  49														    +
   1223				     dec cx
1  1224	05A0  83 F9 00														    +
   1225				     cmp cx, 0
1  1226	05A3  75 F8														    +
   1227				     jne __Mul
1  1228
1  1229	05A5											     __NoMul:
1  1230	05A5  5A										     pop  dx		     ; pop  +
   1231				     (5)
1  1232	05A6  8B C8										     mov  cx, ax
1  1233
1  1234	05A8  58										     pop ax		     ; pop  +
   1235				     (4)
1  1236	05A9  03 C1										     add ax, cx
1  1237	05AB  59										     pop cx		     ; pop  +
   1238				     (3)
1  1239
1  1240	05AC  42										     inc dx		     ; i++
1  1241
1  1242	05AD  3B D1										     cmp dx, cx		     ; if( i+
   1243				     ==	CX )
1  1244	05AF  75 D3										     jne __Next
1  1245
1  1246	05B1  5E 5A						     pop si dx		     ; pop  (2)	(1)
1  1247
1  1248	05B3  C3						     ret
1  1249	05B4							     endp
1  1250
1  1251				     ;------------------------------------------------
   1252				     include	     REG_PRNT.ASM    ; Print AX	in BIN/DEC/HEX
1  1253
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 23
main.asm



1  1254				     ;------------------------------------------------
1  1255				     ;	     PRINT AX IN BIN
1  1256				     ;------------------------------------------------
1  1257				     ; ENTRY:	     AX	= NUM
1  1258				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1259				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1260				     ; EXIT:	     NONE
1  1261				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1262				     ; DESTROYS:     NONE
1  1263				     ;------------------------------------------------
1  1264
1  1265	      =0010		     bin_len = 16d						     ; len of bin str
1  1266
1  1267	05B4			     PrintBin		     proc
1  1268
1  1269	05B4  57						     push di				     ; push (0)
1  1270
1  1271	05B5  50						     push ax				     ; push (1)
1  1272
1  1273	05B6  E8 FC41						     call GetVideoPos		     ; AX = Video position from	(X; +
   1274				     Y)
1  1275	05B9  BF 0020						     mov di, bin_len * 2d    ; i = bin_len * 2 + AX
1  1276	05BC  03 F8						     add di, ax
1  1277	05BE  FD						     std
1  1278
1  1279	05BF  58						     pop  ax				     ; pop  (1)
1  1280
1  1281	05C0  50 52						     push ax dx				     ; push (2)	(3)
1  1282
1  1283	05C2  33 D2						     xor  dx, dx			     ; i = 0
1  1284
1  1285	05C4  D1 E8						     __Next:		     shr ax, 1				    +
   1286				     ; AX /= 2
1  1287
1  1288	05C6  50										     push ax			    +
   1289				     ; push (4)
1  1290
1  1291	05C7  72 05										     jc	__One
1  1292
1  1293	05C9  B0 30										     __Zero:		     mov al,+
   1294				     '0'		     ; '0'
1  1295	05CB  EB 03 90														    +
   1296				     jmp __End
1  1297
1  1298	05CE  B0 31										     __One:		     mov al,+
   1299				     '1'		     ; '1'
1  1300
1  1301	05D0  B4 70						     __End:		     mov ah, 70h			    +
   1302				     ; black on	white
1  1303
1  1304	05D2  83 EF 02										     sub di, 2			    +
   1305				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1306	05D5  AB										     stosw
1  1307	05D6  83 C7 02										     add di, 2
1  1308
1  1309	05D9  58										     pop ax			    +
   1310				     ; pop (4)
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 24
main.asm



1  1311
1  1312	05DA  42										     inc dx
1  1313
1  1314	05DB  83 FA 10										     cmp dx, bin_len		    +
   1315				     ; if( dx == bin_len )
1  1316	05DE  75 E4										     jne __Next
1  1317
1  1318	05E0  5A 58						     pop dx ax			     ; pop  (3)	(2)
1  1319	05E2  5F						     pop di			     ; pop  (0)
1  1320
1  1321	05E3  C3						     ret
1  1322	05E4							     endp
1  1323
1  1324				     ;------------------------------------------------
1  1325				     ;	     PRINT AX IN HEX
1  1326				     ;------------------------------------------------
1  1327				     ; ENTRY:	     AX	= NUM
1  1328				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1329				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1330				     ; EXIT:	     NONE
1  1331				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1332				     ; DESTROYS:     NONE
1  1333				     ;------------------------------------------------
1  1334
1  1335	      =0004		     hex_len = 4d						     ; len of hex str
1  1336
1  1337	05E4			     PrintHex		     proc
1  1338
1  1339	05E4  57						     push di				     ; push (0)
1  1340
1  1341	05E5  50						     push ax				     ; push (1)
1  1342
1  1343	05E6  E8 FC11						     call GetVideoPos		     ; AX = Video position from	(X; +
   1344				     Y)
1  1345	05E9  BF 0008						     mov di, hex_len * 2d    ; i = hex_len * 2 + AX
1  1346	05EC  03 F8						     add di, ax
1  1347	05EE  FD						     std
1  1348
1  1349	05EF  58						     pop  ax				     ; pop  (1)
1  1350
1  1351	05F0  50 51 52						     push ax cx	dx		     ; push (2)	(3) (4)
1  1352
1  1353	05F3  33 D2						     xor dx, dx				     ; i = 0
1  1354
1  1355	05F5  B9 0000						     __Next:		     mov cx, 0			     ;	    +
   1356				     shifts counter
1  1357
1  1358	05F8  52										     push dx			    +
   1359				     ; push (5)
1  1360	05F9  BA 0000										     mov  dx, 0			    +
   1361				     ; DX = 0
1  1362
1  1363	05FC  D1 E8										     __Shift:		     shr ax,+
   1364				     1		     ; AX /= 2
1  1365
1  1366	05FE  73 09														    +
   1367				     jnc __End
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 25
main.asm



1  1368
1  1369	0600  50														    +
   1370				     __One:		     push ax		     ; push (6)
1  1371	0601  B8 0001														    +
   1372				     mov  ax, 1		     ; AX = 0001b
1  1373	0604  D3 E0														    +
   1374				     shl  ax, cl	     ; DX += 2^CX
1  1375	0606  03 D0														    +
   1376				     add  dx, ax
1  1377	0608  58														    +
   1378				     pop      ax		     ; pop  (6)
1  1379
1  1380	0609  41										     __End:		     inc cx +
   1381				     ; shifts counter ++
1  1382	060A  83 F9 04														    +
   1383				     cmp cx, 4d		     ; if( numShifts ==	4 )
1  1384	060D  75 ED														    +
   1385				     jne __Shift
1  1386
1  1387	060F  8B C8										     mov cx, ax			    +
   1388				     ; CX = AX
1  1389
1  1390	0611  83 FA 0A										     cmp dx, 10d		    +
   1391				     ; if( DX >= 10 )
1  1392	0614  7D 08										     jge __Sym
1  1393
1  1394	0616  83 C2 30										     __Digit:		     add dx,+
   1395				     48d	     ; print( DX + '0' )
1  1396	0619  8A C2														    +
   1397				     mov al, dl
1  1398	061B  EB 09 90														    +
   1399				     jmp __Print
1  1400
1  1401	061E  83 EA 0A										     __Sym:		     sub dx,+
   1402				     10		     ; print( DX - 10 +	'A' )
1  1403	0621  83 C2 41														    +
   1404				     add dx, 65d
1  1405	0624  8A C2														    +
   1406				     mov al, dl
1  1407
1  1408	0626  5A						     __Print:		     pop dx			     ; pop  +
   1409				     (5)
1  1410
1  1411	0627  B4 70										     mov ah, 70h		    +
   1412				     ; black on	white
1  1413
1  1414	0629  83 EF 02										     sub di, 2			    +
   1415				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1416	062C  AB										     stosw
1  1417	062D  83 C7 02										     add di, 2
1  1418
1  1419	0630  8B C1										     mov ax, cx			    +
   1420				     ; AX = CX
1  1421
1  1422	0632  42										     inc dx			    +
   1423				     ; i++
1  1424
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 26
main.asm



1  1425	0633  83 FA 04										     cmp dx, hex_len	     ; if(  +
   1426				     dx	== hex_len )
1  1427	0636  75 BD										     jne __Next
1  1428
1  1429	0638  5A 59 58						     pop dx cx ax		     ; pop  (4)	(3) (2)
1  1430	063B  5F						     pop di				     ; pop  (0)
1  1431
1  1432	063C  C3						     ret
1  1433	063D							     endp
1  1434
1  1435				     ;------------------------------------------------
1  1436				     ;	     PRINT AX IN DEC
1  1437				     ;------------------------------------------------
1  1438				     ; ENTRY:	     AX	= NUM
1  1439				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1440				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1441				     ; EXIT:	     NONE
1  1442				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1443				     ; DESTROYS:     NONE
1  1444				     ;------------------------------------------------
1  1445
1  1446	      =0005		     dec_len = 5d
1  1447
1  1448	063D			     PrintDec		     proc
1  1449
1  1450	063D  57						     push di				     ; pop  (0)
1  1451
1  1452	063E  50						     push ax				     ; push (1)
1  1453
1  1454	063F  E8 FBB8						     call GetVideoPos		     ; AX = Video position from	(X; +
   1455				     Y)
1  1456	0642  BF 000A						     mov di, dec_len * 2d    ; i = dec_len * 2 + AX
1  1457	0645  03 F8						     add di, ax
1  1458	0647  FD						     std
1  1459
1  1460	0648  58						     pop  ax				     ; pop  (1)
1  1461
1  1462	0649  50 51 52						     push ax cx	dx		     ; push (2)	(3) (4)
1  1463
1  1464	064C  33 D2						     xor dx, dx				     ; i = 0
1  1465	064E  B9 000A						     mov cx, 10d			     ; CX = 10
1  1466
1  1467	0651  52						     __Next:		     push dx			     ; push +
   1468				     (5)
1  1469
1  1470	0652  33 D2										     xor dx, dx			    +
   1471				     ; DX = 0
1  1472
1  1473	0654  F7 F1										     div  cx			    +
   1474				     ; AX /= 10
1  1475
1  1476	0656  50										     push ax			    +
   1477				     ; push (6)
1  1478
1  1479	0657  80 C2 30										     add  dl, 48d	     ; print+
   1480				     ( DL + '0'	)
1  1481	065A  8A C2										     mov  al, dl
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 27
main.asm



1  1482
1  1483	065C  B4 70										     mov  ah, 70h	     ; black+
   1484				     on	white
1  1485
1  1486	065E  83 EF 02										     sub di, 2			    +
   1487				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1488	0661  AB										     stosw
1  1489	0662  83 C7 02										     add di, 2
1  1490
1  1491	0665  58										     pop ax			    +
   1492				     ; pop  (6)
1  1493	0666  5A										     pop dx			    +
   1494				     ; pop  (5)
1  1495
1  1496	0667  42										     inc dx
1  1497
1  1498	0668  83 FA 05										     cmp dx, dec_len	     ; if(  +
   1499				     DX	== dec_len )
1  1500	066B  75 E4										     jne __Next
1  1501
1  1502	066D  5A 59 58						     pop dx cx ax		     ; pop  (4)	(3) (2)
1  1503	0670  5F						     pop di				     ; pop  (0)
1  1504
1  1505	0671  C3						     ret
1  1506	0672							     endp
1  1507
1  1508				     ;------------------------------------------------
1  1509				     ;	     PRINT AX IN BIN/HEX/DEC
1  1510				     ;------------------------------------------------
1  1511				     ; ENTRY:	     AX	= NUM
1  1512				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1513				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1514				     ; EXIT:	     NONE
1  1515				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1516				     ; DESTROYS:     NONE
1  1517				     ;------------------------------------------------
1  1518
1  1519	0672			     PrintNum		     proc
1  1520
1  1521	0672  53						     push bx				     ; push (1)
1  1522
1  1523	0673  E8 FF3E						     call PrintBin
1  1524
1  1525	0676  80 C7 11						     add bh, bin_len + 1d    ; X
1  1526	0679  E8 FF68						     call PrintHex
1  1527
1  1528	067C  80 C7 05						     add bh, hex_len + 1d    ; X
1  1529	067F  E8 FFBB						     call PrintDec
1  1530
1  1531	0682  5B						     pop bx				     ; pop  (1)
1  1532
1  1533	0683  C3						     ret
1  1534	0684							     endp
1  1535
1  1536				     ;------------------------------------------------
1  1537
   1538
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 28
main.asm



   1539	0684			     EOP:
   1540
   1541				     end		     Start
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 29
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "03/04/23"
??FILENAME			  Text	 "main	  "
??TIME				  Text	 "00:55:15"
??VERSION			  Number 040A
@32BIT				  Text	 0
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0707H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 MAIN
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
ANIMBOX				  Near	 DGROUP:03C6
ATOI				  Near	 DGROUP:057E
BIN_LEN				  Number 0010
BOXDATA				  Byte	 DGROUP:03B2
CLRSCREEN			  Near	 DGROUP:01EC
CLR_NUM				  Number 0004
DEC_LEN				  Number 0005
EMPTYSTR			  Byte	 DGROUP:03B1
EOP				  Near	 DGROUP:0684
FILLSCREEN			  Near	 DGROUP:01BE
GETVIDEOPOS			  Near	 DGROUP:01FA
HEX_LEN				  Number 0004
H_NUM				  Number 0003
INPUT				  Near	 DGROUP:048A
INPUTLEN			  Number 0064
INPUTSTR			  Byte	 DGROUP:0426
ISPRINTREG			  Byte	 DGROUP:014A
MEMCHR				  Near	 DGROUP:04BF
MEMCMP				  Near	 DGROUP:0536
MEMCPY				  Near	 DGROUP:0504
MEMSET				  Near	 DGROUP:04F1
NEW08				  Near	 DGROUP:014B
NEW09				  Near	 DGROUP:0186
OLD_08_OFS			  Word	 DGROUP:0181
OLD_08_SEG			  Word	 DGROUP:0183
OLD_09_OFS			  Word	 DGROUP:01B9
OLD_09_SEG			  Word	 DGROUP:01BB
PRINTBIN			  Near	 DGROUP:05B4
PRINTBOX			  Near	 DGROUP:02E4
PRINTCHAR			  Near	 DGROUP:020C
PRINTDEC			  Near	 DGROUP:063D
PRINTHEX			  Near	 DGROUP:05E4
PRINTHRZLINE			  Near	 DGROUP:023D
PRINTNUM			  Near	 DGROUP:0672
PRINTSTR			  Near	 DGROUP:0217
PRINTVRTLINE			  Near	 DGROUP:027A
START				  Near	 DGROUP:0100
STRCHR				  Near	 DGROUP:04DA
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 30
Symbol Table



STRCMP				  Near	 DGROUP:055C
STRCPY				  Near	 DGROUP:051F
STRLEN				  Near	 DGROUP:04AA
TYPE_0				  Byte	 DGROUP:02B7
TYPE_1				  Byte	 DGROUP:02C0
TYPE_2				  Byte	 DGROUP:02C9
TYPE_3				  Byte	 DGROUP:02D2
TYPE_4				  Byte	 DGROUP:02DB
TYPE_NUM			  Number 0005
W_NUM				  Number 0002
X_NUM				  Number 0000
X_POS				  Number 0002
Y_NUM				  Number 0001
__DIGIT				  Near	 DGROUP:0616
__END				  Near	 DGROUP:017A
__END				  Near	 DGROUP:01DA
__END				  Near	 DGROUP:0238
__END				  Near	 DGROUP:0279
__END				  Near	 DGROUP:02B6
__END				  Near	 DGROUP:0416
__END				  Near	 DGROUP:04A6
__END				  Near	 DGROUP:04BC
__END				  Near	 DGROUP:04D8
__END				  Near	 DGROUP:04EF
__END				  Near	 DGROUP:0502
__END				  Near	 DGROUP:051C
__END				  Near	 DGROUP:0532
__END				  Near	 DGROUP:0559
__END				  Near	 DGROUP:057B
__END				  Near	 DGROUP:05D0
__END				  Near	 DGROUP:0609
__ENDNEXTLINE			  Near	 DGROUP:01E8
__ENDPRINTING			  Near	 DGROUP:0275
__ENDPRINTING			  Near	 DGROUP:02B2
__FOUND				  Near	 DGROUP:04D4
__FOUND				  Near	 DGROUP:04EB
__MUL				  Near	 DGROUP:059D
__NEXT				  Near	 DGROUP:01CB
__NEXT				  Near	 DGROUP:021D
__NEXT				  Near	 DGROUP:0268
__NEXT				  Near	 DGROUP:02A5
__NEXT				  Near	 DGROUP:03EC
__NEXT				  Near	 DGROUP:048D
__NEXT				  Near	 DGROUP:04AE
__NEXT				  Near	 DGROUP:04C9
__NEXT				  Near	 DGROUP:04DF
__NEXT				  Near	 DGROUP:04F9
__NEXT				  Near	 DGROUP:050F
__NEXT				  Near	 DGROUP:0526
__NEXT				  Near	 DGROUP:0541
__NEXT				  Near	 DGROUP:0562
__NEXT				  Near	 DGROUP:0584
__NEXT				  Near	 DGROUP:05C4
__NEXT				  Near	 DGROUP:05F5
__NEXT				  Near	 DGROUP:0651
__NEXTLINE			  Near	 DGROUP:01C8
__NOINCH			  Near	 DGROUP:0403
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 31
Symbol Table



__NOINCW			  Near	 DGROUP:03F9
__NOMUL				  Near	 DGROUP:05A5
__NOPRINTREGS			  Near	 DGROUP:01B7
__ONE				  Near	 DGROUP:05CE
__ONE				  Near	 DGROUP:0600
__PRINT				  Near	 DGROUP:0626
__PRINTREGS			  Near	 DGROUP:0190
__SHIFT				  Near	 DGROUP:05FC
__SYM				  Near	 DGROUP:061E
__ZERO				  Near	 DGROUP:05C9

Macro Name

EXIT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  0684 Word	  Public  CODE
Turbo Assembler	 Version 4.1	    03/04/23 00:55:16	    Page 32
Error Summary



**Error** NEW_RESD.ASM(63) Illegal immediate
