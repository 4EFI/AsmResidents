Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 1
chg_resd.asm



      1
      2				     .286
      3	0000			     .model tiny
      4	0000			     .code
      5				     org 100h
      6
      7				     locals __
      8
      9				     include		 TOOLS.ASM				 ; Exit
1    10
1    11				     ;------------------------------------------------
1    12				     ;	     EXIT PROGRAM
1    13				     ;------------------------------------------------
1    14				     ; Entry:	     NONE
1    15				     ; EXIT:	     NONE
1    16				     ; DESTROYS: AX
1    17				     ;------------------------------------------------
1    18
1    19				     EXIT	     macro
1    20							     nop
1    21							     mov ax, 4c00h
1    22							     int 21h
1    23							     nop
1    24							     endm
1    25
1    26				     ;------------------------------------------------
     27
     28				     ;------------------------------------------------
     29
     30	0100  33 DB		     Start:	     xor bx, bx			 ; ES =	0
     31	0102  8E C3				     mov es, bx
     32
     33	0104  BB 0020				     mov bx, 4d	* 8d		 ; BX =	4*8 ( 8th Intr - Timer )
     34
     35	0107  FA				     cli			 ; START NO-INTR
     36
     37	0108  26: 8B 07				     mov ax, es:[bx]		 ; Old_08_Ofs =	0:[4*8]
     38	010B  A3 01A4r				     mov Old_08_Ofs, ax
     39
     40	010E  26: C7 07	0150r			     mov es:[bx], offset New08	 ; 0:[4*8] = New_Intr_Func_Ofs
     41
     42	0113  26: 8B 47	02			     mov ax, es:[bx + 2]	 ; Old_08_Seg =	0:[4*8 + 2]
     43	0117  A3 01A6r				     mov Old_08_Seg, ax
     44
     45	011A  8C C8				     mov ax, cs
     46	011C  26: 89 47	02			     mov es:[bx	+ 2], ax	 ; 0:[4*8 + 2] = New_Intr_Func_Seg
     47
     48	0120  BB 0024				     mov bx, 4d	* 9d		 ; BX =	4*9 ( 9th Intr - Keyboard )
     49
     50	0123  26: 8B 07				     mov ax, es:[bx]		 ; Old_09_Ofs =	0:[4*9]
     51	0126  A3 01D2r				     mov Old_09_Ofs, ax
     52
     53	0129  26: C7 07	01A9r			     mov es:[bx], offset New09	 ; 0:[4*9] = New_Intr_Func_Ofs
     54
     55	012E  26: 8B 47	02			     mov ax, es:[bx + 2]	 ; Old_09_Seg =	0:[4*9 + 2]
     56	0132  A3 01D4r				     mov Old_09_Seg, ax
     57
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 2
chg_resd.asm



     58	0135  8C C8				     mov ax, cs
     59	0137  26: 89 47	02			     mov es:[bx	+ 2], ax	 ; 0:[4*9 + 2] = New_Intr_Func_Seg
     60
     61	013B  FB				     sti			 ; END NO-INTR
     62
     63	013C  B8 3100				     mov ax, 3100h		 ; EXIT	with saving
     64	013F  BA 069Br				     mov dx, offset EOP
     65	0142  C1 EA 04				     shr dx, 4
     66	0145  42				     inc dx
     67	0146  CD 21				     int 21h
     68
     69				     ;------------------------------------------------
     70
     71				     include	 NEW_RESD.ASM	 ; Resident programs
1    72
1    73	0148  00		     BoxStrRsd	     db	 0
1    74	0149  00 00 1D 06 4F 01	     BoxDataRsd	     db	 0, 0, 29d, 6, 79d, 1
1    75
1    76	014F  00		     IsPrintReg	     db	 0
1    77
1    78	      =0001		     X_Pos = 1
1    79
1    80	0150			     New08	     proc
1    81
1    82	0150  50 53 51 52			     push ax bx	cx dx
1    83	0154  56 1E 06				     push si ds	es
1    84
1    85	0157  53				     push bx			 ; DS =	CS
1    86	0158  8C CB				     mov  bx, cs
1    87	015A  8E DB				     mov  ds, bx
1    88	015C  5B				     pop  bx
1    89
1    90	015D  80 3E 014Fr 00			     cmp byte ptr IsPrintReg, 0
1    91	0162  74 34				     je	__End
1    92
1    93	0164  53				     push bx			 ; save	BX
1    94	0165  50				     push ax			 ; save	AX
1    95
1    96	0166  BB B800				     mov  bx, 0b800h		 ; ES =	VideoSeg
1    97	0169  8E C3				     mov  es, bx
1    98
1    99						     ; mov  si,	offset
1   100	016B  B8 0148r				     mov  ax, offset BoxStrRsd
1   101	016E  BB 0149r				     mov  bx, offset BoxDataRsd
1   102	0171  E8 0189				     call PrintBox
1   103
1   104	0174  58				     pop  ax			 ; load	AX
1   105
1   106	0175  B7 01				     mov  bh, X_Pos		 ; (X; Y) = (X_Pos; 1)
1   107	0177  B3 01				     mov  bl, 1
1   108	0179  E8 050D				     call PrintNum		 ; print AX
1   109
1   110	017C  5B				     pop  bx			 ; load	BX
1   111	017D  8B C3				     mov  ax, bx		 ; AX =	BX
1   112	017F  B7 01				     mov  bh, X_Pos		 ; (X; Y) = (X_Pos; 2)
1   113	0181  B3 02				     mov  bl, 2
1   114	0183  E8 0503				     call PrintNum		 ; print BX
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 3
chg_resd.asm



1   115
1   116	0186  8B C1				     mov  ax, cx		 ; AX =	CX
1   117	0188  B7 01				     mov  bh, X_Pos		 ; (X; Y) = (X_Pos; 3)
1   118	018A  B3 03				     mov  bl, 3
1   119	018C  E8 04FA				     call PrintNum		 ; print CX
1   120
1   121	018F  8B C2				     mov  ax, dx		 ; AX =	CX
1   122	0191  B7 01				     mov  bh, X_Pos		 ; (X; Y) = (X_Pos; 4)
1   123	0193  B3 04				     mov  bl, 4
1   124	0195  E8 04F1				     call PrintNum		 ; print CX
1   125
1   126	0198					     __End:
1   127
1   128	0198  B0 20				     mov al, 20h		 ; End-of-Intr
1   129	019A  E6 20				     out 20h, al
1   130
1   131	019C  07 1F 5E				     pop es ds si
1   132	019F  5A 59 5B 58			     pop dx cx bx ax
1   133
1   134	01A3  EA				     db	0eah			 ; jmp Old_08_Seg:[Old_08_Ofs]
1   135	01A4  0000				     Old_08_Ofs	dw 0
1   136	01A6  0000				     Old_08_Seg	dw 0
1   137
1   138	01A8  CF				     iret
1   139	01A9					     endp
1   140
1   141	01A9			     New09	     proc
1   142
1   143	01A9  50				     push ax			 ; save	AX
1   144	01AA  E4 60				     in	  al, 60h		 ; get scan key
1   145	01AC  3C 3B				     cmp  al, 3bh		 ; F1 =	print regs
1   146	01AE  74 03				     je	__PrintRegs
1   147
1   148	01B0  EB 1E 90				     jmp __NoPrintRegs
1   149
1   150	01B3					     __PrintRegs:
1   151
1   152	01B3  1E				     push ds
1   153
1   154	01B4  53				     push bx			 ; DS =	CS
1   155	01B5  8C CB				     mov  bx, cs
1   156	01B7  8E DB				     mov  ds, bx
1   157	01B9  5B				     pop  bx
1   158
1   159	01BA  80 36 014Fr 01			     xor  byte ptr IsPrintReg, 1h
1   160
1   161	01BF  E4 61				     in	 al, 61h		 ; Signal keyboard
1   162	01C1  0C 80				     or	 al, 80h
1   163	01C3  E6 61				     out 61h, al
1   164	01C5  24 7F				     and al, not 80h
1   165	01C7  E6 61				     out 61h, al
1   166
1   167	01C9  B0 20				     mov al, 20h		 ; End-of-Intr
1   168	01CB  E6 20				     out 20h, al
1   169
1   170	01CD  1F				     pop ds
1   171
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 4
chg_resd.asm



1   172	01CE  58				     pop ax			 ; load	AX
1   173	01CF  CF				     iret
1   174
1   175	01D0					     __NoPrintRegs:
1   176
1   177	01D0  58				     pop  ax			 ; losd	AX
1   178
1   179	01D1  EA				     db	0eah			 ; jmp Old_09_Seg:[Old_09_Ofs]
1   180	01D2  0000				     Old_09_Ofs	dw 0
1   181	01D4  0000				     Old_09_Seg	dw 0
1   182
1   183	01D6  CF				     iret
1   184	01D7					     endp
1   185
    186				     include	     SCR_HNDL.ASM    ; Clear screen function
1   187
1   188				     ; SCREEN HANDLER
1   189
1   190				     ;------------------------------------------------
1   191				     ;	     FILL SCREEN BY SYM
1   192				     ;	     FROM ( X; Y ) to (	X + WIDTH; Y + HEIGHT )
1   193				     ;------------------------------------------------
1   194				     ; ENTRY:	     AH	= COLOR	ATTR
1   195				     ;			     AL	= SYM
1   196				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   197				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   198				     ;			     CH	= WIDTH
1   199				     ;			     CL	= HEIGHT
1   200				     ; EXIT:	     NONE
1   201				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   202				     ; DESTROYS:     NONE
1   203				     ;------------------------------------------------
1   204
1   205	01D7			     FillScreen		     proc
1   206
1   207	01D7  53						     push bx			     ; push (1)
1   208	01D8  51						     push cx			     ; push (2)
1   209	01D9  52						     push dx			     ; push (3)
1   210
1   211	01DA  50						     push ax			     ; push (4)
1   212	01DB  E8 0035						     call GetVideoPos
1   213	01DE  8B D8						     mov bx, ax
1   214	01E0  58						     pop ax			     ; pop  (4)
1   215
1   216	01E1  8A F5						     __NextLine:		     mov dh, ch		     ; i =  +
    217				     CH
1   218
1   219	01E3  53											     push bx		    +
    220				     ; push (5)
1   221
1   222	01E4  26: 89 07											     __Next:		    +
    223				     mov es:[bx], ax
1   224	01E7  83 C3 02														    +
    225				     add bx, 2
1   226
1   227	01EA  FE CE														    +
    228				     dec dh		     ; i--
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 5
chg_resd.asm



1   229
1   230	01EC  80 FE 00														    +
    231				     cmp dh, 0d		     ; if( dh == 0 )
1   232	01EF  74 02														    +
    233				     je	__End
1   234
1   235	01F1  EB F1														    +
    236				     jmp __Next
1   237	01F3												     __End:
1   238
1   239	01F3  5B											     pop bx		    +
    240				     ; pop  (5)
1   241
1   242	01F4  81 C3 00A0										     add bx, 160d    ; BX +=+
    243				     2*80
1   244
1   245	01F8  FE C9											     dec cl		    +
    246				     ; CL--
1   247
1   248	01FA  80 F9 00											     cmp cl, 0d	     ; if(  +
    249				     CL	== 0 )
1   250	01FD  74 02											     je	__EndNextLine
1   251
1   252	01FF  EB E0											     jmp __NextLine
1   253	0201							     __EndNextLine:
1   254
1   255	0201  5A						     pop dx			     ; pop  (3)
1   256	0202  59						     pop cx			     ; pop  (2)
1   257	0203  5B						     pop bx			     ; pop  (1)
1   258
1   259	0204  C3						     ret
1   260	0205							     endp
1   261
1   262				     ;------------------------------------------------
1   263				     ;	     CLEAR SCREEN BY SYM
1   264				     ;------------------------------------------------
1   265				     ; ENTRY:	     AH	= COLOR	ATTR
1   266				     ;			     AL	= SYM
1   267				     ; EXIT:	     NONE
1   268				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   269				     ; DESTROYS:     NONE
1   270				     ;------------------------------------------------
1   271
1   272	0205			     ClrScreen		     proc
1   273
1   274	0205  53						     push bx			     ; push (1)
1   275	0206  51						     push cx			     ; push (2)
1   276
1   277	0207  33 DB						     xor bx, bx			     ; X = 0; Y	= 0
1   278	0209  B5 50						     mov ch, 80d
1   279	020B  B1 19						     mov cl, 25d
1   280	020D  E8 FFC7						     call FillScreen
1   281
1   282	0210  59						     pop cx			     ; pop  (2)
1   283	0211  5B						     pop bx			     ; pop  (1)
1   284
1   285	0212  C3						     ret
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 6
chg_resd.asm



1   286	0213							     endp
1   287
1   288				     ;------------------------------------------------
1   289				     ;	     GET VIDEO POS FROM	(X; Y)
1   290				     ;------------------------------------------------
1   291				     ; ENTRY:	     BH	= X LEFT CORNER	COORDS [0; 79]
1   292				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   293				     ; EXIT:	     AX	= POS
1   294				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   295				     ; DESTROYS:     AX
1   296				     ;------------------------------------------------
1   297
1   298	0213			     GetVideoPos	     proc
1   299
1   300	0213  D0 E7						     shl bh, 1		     ; bh /= 2
1   301
1   302	0215  52						     push dx		     ; push (1)
1   303
1   304	0216  B0 A0						     mov al, 160d    ; ax = 160	* Y + 2	* X
1   305	0218  F6 E3						     mul bl
1   306	021A  BA 0000						     mov dx, 0
1   307	021D  02 D7						     add dl, bh
1   308	021F  03 C2						     add ax, dx
1   309
1   310	0221  5A						     pop dx		     ; pop  (1)
1   311
1   312	0222  D0 EF						     shr bh, 1		     ; bh *= 2
1   313
1   314	0224  C3						     ret
1   315	0225							     endp
1   316
1   317				     ;------------------------------------------------
1   318				     ;	     PRINT SYM IN (X; Y)
1   319				     ;------------------------------------------------
1   320				     ; ENTRY:	     AH	= SYM COLOR
1   321				     ;			     AL	= SYM CHAR
1   322				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   323				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   324				     ; EXIT:	     NONE
1   325				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   326				     ; DESTROYS:     NONE
1   327				     ;------------------------------------------------
1   328
1   329	0225			     PrintChar		     proc
1   330
1   331	0225  57						     push di		     ; push (1)
1   332	0226  50						     push ax		     ; push (2)
1   333
1   334	0227  E8 FFE9						     call GetVideoPos
1   335
1   336	022A  8B F8						     mov di, ax		     ; print( ax )
1   337	022C  58						     pop ax		     ; pop  (2)
1   338	022D  AB						     stosw
1   339
1   340	022E  5F						     pop di		     ; pop  (1)
1   341
1   342	022F  C3						     ret
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 7
chg_resd.asm



1   343	0230							     endp
1   344
1   345				     ;------------------------------------------------
1   346				     ;	     PRINT STR IN (X; Y)
1   347				     ;------------------------------------------------
1   348				     ; ENTRY:	     AH	= SYM COLOR
1   349				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   350				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   351				     ;			     CX	= STR ADDR
1   352				     ; EXIT:	     NONE
1   353				     ; EXPECTS:	     ES	     = 0b800h (VIDEO SEGMENT)
1   354				     ;			     END SYM = '\0' || '$' || '\r'
1   355				     ; DESTROYS:     NONE
1   356				     ;------------------------------------------------
1   357
1   358	0230			     PrintStr		     proc
1   359
1   360	0230  50						     push ax		     ; push (1)
1   361	0231  53						     push bx		     ; push (2)
1   362	0232  52						     push dx		     ; push (3)
1   363	0233  56						     push si		     ; push (4)
1   364
1   365	0234  8B F1						     mov si, cx		     ; SI = StrAddr
1   366
1   367	0236  8A 14						     __Next:		     mov dl, [si]    ; DX = CurrSym
1   368
1   369	0238  80 FA 00										     cmp dl, 0d		     ; if(  +
    370				     DL	== 0 )
1   371	023B  74 14										     je	__End
1   372	023D  80 FA 0D										     cmp dl, 13d	     ; if(  +
    373				     DL	== '\r'	)
1   374	0240  74 0F										     je	__End
1   375	0242  80 FA 24										     cmp dl, '$'	     ; if(  +
    376				     DL	== '$' )
1   377	0245  74 0A										     je	__End
1   378
1   379	0247  8A 04										     mov al, [si]    ; AL = CurrSym
1   380	0249  E8 FFD9										     call PrintChar
1   381
1   382	024C  FE C7										     inc bh		     ; X++
1   383	024E  46										     inc si		     ;	    +
    384				     CurrSymPos++
1   385
1   386	024F  E2 E5										     loop __Next
1   387	0251							     __End:
1   388
1   389	0251  5E						     pop si		     ; pop  (4)
1   390	0252  5A						     pop dx		     ; pop  (3)
1   391	0253  58						     pop ax		     ; pop  (2)
1   392	0254  5B						     pop bx		     ; pop  (1)
1   393
1   394	0255  C3						     ret
1   395	0256							     endp
1   396
1   397				     ;------------------------------------------------
1   398				     ;	     PRINT HORIZONTAL LINE IN (X; Y)
1   399				     ;------------------------------------------------
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 8
chg_resd.asm



1   400				     ; ENTRY:	     AH	= SYM COLOR
1   401				     ;			     AL	= SYM CHAR
1   402				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   403				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   404				     ;			     CH	= WIDTH
1   405				     ;			     DH	= LEFT	SYM
1   406				     ;			     DL	= RIGHT	SYM
1   407				     ; EXIT:	     NONE
1   408				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   409				     ; DESTROYS:     NONE
1   410				     ;------------------------------------------------
1   411
1   412	0256			     PrintHrzLine    proc
1   413
1   414	0256  80 FD 01						     cmp ch, 1			     ; if( ch <= 1 ) ret
1   415	0259  76 37						     jbe __End
1   416
1   417	025B  53						     push bx			     ; push (1)
1   418	025C  52						     push dx			     ; push (2)
1   419
1   420
1   421	025D  50						     push ax			     ; push (3)
1   422	025E  8A C6						     mov al, dh			     ; printf( "%c", LeftSym )
1   423	0260  E8 FFC2						     call PrintChar
1   424	0263  58						     pop ax			     ; pop  (3)
1   425
1   426	0264  50						     push ax			     ; push (4)
1   427	0265  53						     push bx			     ; push (5)
1   428	0266  02 FD						     add bh, ch			     ; X += ( WIDTH - 1	)
1   429	0268  80 EF 01						     sub bh, 1
1   430	026B  8A C2						     mov al, dl			     ; printf( "%c", RightSym )
1   431	026D  E8 FFB5						     call PrintChar
1   432	0270  5B						     pop bx			     ; pop  (5)
1   433	0271  58						     pop ax			     ; pop  (4)
1   434
1   435	0272  53						     push bx			     ; push (6)
1   436	0273  51						     push cx			     ; push (7)
1   437
1   438	0274  80 C7 01						     add bh, 1			     ; X += 1
1   439	0277  80 ED 02						     sub ch, 2			     ; WIDTH -=	2
1   440
1   441	027A  80 FD 00						     cmp ch, 0			     ; if( ch == 0 )
1   442	027D  74 0F						     je	     __EndPrinting
1   443
1   444	027F  33 D2						     xor dx, dx			     ; i = 0
1   445
1   446	0281  E8 FFA1						     __Next:		     call PrintChar
1   447
1   448	0284  FE C7										     inc bh
1   449	0286  FE C6										     inc dh
1   450
1   451	0288  3A F5										     cmp dh, ch
1   452	028A  74 02										     je	 __EndPrinting
1   453
1   454	028C  EB F3										     jmp __Next
1   455
1   456	028E							     __EndPrinting:
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 9
chg_resd.asm



1   457
1   458	028E  59						     pop cx			     ; pop  (7)
1   459	028F  5B						     pop bx			     ; pop  (6)
1   460
1   461
1   462	0290  5A						     pop dx			     ; pop  (2)
1   463	0291  5B						     pop bx			     ; pop  (1)
1   464
1   465	0292							     __End:
1   466	0292  C3						     ret
1   467	0293							     endp
1   468
1   469				     ;------------------------------------------------
1   470				     ;	     PRINT VERTICAL LINE IN (X;	Y)
1   471				     ;------------------------------------------------
1   472				     ; ENTRY:	     AH	= SYM COLOR
1   473				     ;			     AL	= SYM CHAR
1   474				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1   475				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1   476				     ;			     CL	= HEIGHT
1   477				     ;			     DH	= TOP  SYM
1   478				     ;			     DL	= DOWN SYM
1   479				     ; EXIT:	     NONE
1   480				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   481				     ; DESTROYS:     NONE
1   482				     ;------------------------------------------------
1   483
1   484	0293			     PrintVrtLine    proc
1   485
1   486	0293  80 F9 01						     cmp cl, 1			     ; if( cl <= 1 ) ret
1   487	0296  76 37						     jbe __End
1   488
1   489	0298  53						     push bx			     ; push (1)
1   490	0299  52						     push dx			     ; push (2)
1   491
1   492
1   493	029A  50						     push ax			     ; push (3)
1   494	029B  8A C6						     mov al, dh			     ; printf( "%c", TopSym )
1   495	029D  E8 FF85						     call PrintChar
1   496	02A0  58						     pop ax			     ; pop  (3)
1   497
1   498	02A1  50						     push ax			     ; push (4)
1   499	02A2  53						     push bx			     ; push (5)
1   500	02A3  02 D9						     add bl, cl			     ; Y += ( HEIGHT - 1 )
1   501	02A5  80 EB 01						     sub bl, 1
1   502	02A8  8A C2						     mov al, dl			     ; printf( "%c", DownSym )
1   503	02AA  E8 FF78						     call PrintChar
1   504	02AD  5B						     pop bx			     ; pop  (5)
1   505	02AE  58						     pop ax			     ; pop  (4)
1   506
1   507	02AF  53						     push bx			     ; push (6)
1   508	02B0  51						     push cx			     ; push (7)
1   509
1   510	02B1  80 C3 01						     add bl, 1			     ; Y += 1
1   511	02B4  80 E9 02						     sub cl, 2			     ; HEIGHT -= 2
1   512
1   513	02B7  80 F9 00						     cmp cl, 0			     ; if( cl == 0 )
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 10
chg_resd.asm



1   514	02BA  74 0F						     je	     __EndPrinting
1   515
1   516	02BC  33 D2						     xor dx, dx			     ; i = 0
1   517
1   518	02BE  E8 FF64						     __Next:		     call PrintChar
1   519
1   520	02C1  FE C3										     inc bl
1   521	02C3  FE C2										     inc dl
1   522
1   523	02C5  3A D1										     cmp dl, cl
1   524	02C7  74 02										     je	 __EndPrinting
1   525
1   526	02C9  EB F3										     jmp __Next
1   527
1   528	02CB							     __EndPrinting:
1   529
1   530	02CB  59						     pop cx			     ; pop  (7)
1   531	02CC  5B						     pop bx			     ; pop  (6)
1   532
1   533
1   534	02CD  5A						     pop dx			     ; pop  (2)
1   535	02CE  5B						     pop bx			     ; pop  (1)
1   536
1   537	02CF							     __End:
1   538	02CF  C3						     ret
1   539	02D0							     endp
1   540
1   541				     ;------------------------------------------------
1   542				     ;	     PRINT BOX
1   543				     ;------------------------------------------------
1   544				     ; ENTRY:	     AX	= STR  ADDR
1   545				     ;			     BX	= DATA ADDR
1   546				     ; EXIT:	     NONE
1   547				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   548				     ; DESTROYS:     NONE
1   549				     ;------------------------------------------------
1   550
1   551				     ; User's type
1   552	02D0  09*(00)		     Type_0  db		     9 dup (0)
1   553
1   554				     ; Template	types
1   555				     ;				     0		     1		     2		     3		    +
    556				     4		     5		     6		     7		     9
1   557				     ;				     lt		     ld		     rt		     rd		    +
    558				     lv		     rv		     th		     dh		     fill
1   559	02D9  C9 C8 BB BC BA BA	CD+  Type_1  db		     0c9h,   0c8h,   0bbh,   0bch,   0bah,   0bah,   0cdh,   0cdh,   0d
    560	      CD 00
1   561	02E2  03 03 03 03 03 03	03+  Type_2  db		     003h,   003h,   003h,   003h,   003h,   003h,   003h,   003h,   '-'
    562	      03 2D
1   563	02EB  BC BB C8 C9 CD CD	BA+  Type_3  db		     0bch,   0bbh,   0c8h,   0c9h,   0cdh,   0cdh,   0bah,   0bah,   0d
    564	      BA 00
1   565	02F4  DA C0 BF D9 B3 B3	C4+  Type_4  db		     0dah,   0c0h,   0bfh,   0d9h,   0b3h,   0b3h,   0c4h,   0c4h,   0d
    566	      C4 00
1   567
1   568	      =0000		     X_Num    =	0
1   569	      =0001		     Y_Num    =	1
1   570	      =0002		     W_Num    =	2
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 11
chg_resd.asm



1   571	      =0003		     H_Num    =	3
1   572	      =0004		     Clr_Num  =	4
1   573	      =0005		     Type_Num =	5
1   574
1   575	02FD			     PrintBox		     proc
1   576
1   577	02FD  50						     push ax				     ; push (1)
1   578	02FE  53						     push bx				     ; push (2)
1   579	02FF  51						     push cx				     ; push (3)
1   580	0300  52						     push dx				     ; push (4)
1   581	0301  56						     push si				     ; push (5)
1   582	0302  57						     push di				     ; push (6)
1   583	0303  57						     push di				     ; push (7)
1   584
1   585	0304  50						     push ax				     ; push (8)	<> push	STR +
    586				     ADDR
1   587
1   588	0305  8B F3						     mov si, bx				     ; SI = DATA ADDR( BX )
1   589
1   590								     ; SET TYPE	BOX
1   591
1   592	0307  33 C0						     xor ax, ax				     ; DI = Type_0 + Type * 9
1   593	0309  8A 47 05						     mov al, bx[Type_Num]
1   594	030C  B9 0009						     mov cx, 9d
1   595	030F  F7 E1						     mul cx
1   596	0311  8B F8						     mov di, ax
1   597	0313  81 C7 02D0r					     add di, offset Type_0
1   598
1   599	0317  8A 67 04						     mov ah, bx[Clr_Num]	     ; AH = Color
1   600
1   601	031A  8A 6F 02						     mov ch, bx[W_Num]		     ; CH = WIDTH
1   602	031D  8A 4F 03						     mov cl, bx[H_Num]		     ; CL = HEIGHT
1   603
1   604								     ; PRINT TOP HORIZONTAL LINE
1   605
1   606	0320  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
1   607	0322  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   608	0325  8A 45 06						     mov  al, di[6]		     ; AL = horizontal sym
1   609	0328  8A 35						     mov  dh, di[0]		     ; DH = left  top  sym
1   610	032A  8A 55 02						     mov  dl, di[2]		     ; DL = right top  sym
1   611	032D  E8 FF26						     call PrintHrzLine
1   612
1   613								     ; PRINT LEFT VERTICAL LINE
1   614
1   615	0330  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
1   616	0332  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   617	0335  8A 45 04						     mov  al, di[4]		     ; AL = vertical  sym
1   618	0338  8A 35						     mov  dh, di[0]		     ; DH = left top  sym
1   619	033A  8A 55 01						     mov  dl, di[1]		     ; DL = left down sym
1   620	033D  E8 FF53						     call PrintVrtLine
1   621
1   622	0340  53						     push bx				     ; push (9)	<> push	(X; +
    623				     Y)
1   624
1   625								     ; PRINT DOWN HORIZONTAL LINE
1   626
1   627	0341  8A 3C						     mov  bh, si[X_Num]		     ; BH = X
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 12
chg_resd.asm



1   628	0343  8A 54 01						     mov  dl, si[Y_Num]		 ; Y +=	( HEIGHT - 1 )
1   629	0346  02 D1						     add  dl, cl
1   630	0348  80 EA 01						     sub  dl, 1
1   631	034B  8A DA						     mov  bl, dl			     ; BL = Y
1   632	034D  8A 45 07						     mov  al, di[7]		     ; AL = horizontal sym
1   633	0350  8A 75 01						     mov  dh, di[1]		     ; DH = left  down sym
1   634	0353  8A 55 03						     mov  dl, di[3]		     ; DL = right down sym
1   635	0356  E8 FEFD						     call PrintHrzLine
1   636
1   637								     ; PRINT RIGHT VERTICAL LINE
1   638
1   639	0359  8A 14						     mov  dl, si[X_Num]		 ; X +=	( WIDTH	- 1 )
1   640	035B  02 D5						     add  dl, ch
1   641	035D  80 EA 01						     sub  dl, 1
1   642	0360  8A FA						     mov  bh, dl			     ; BH = X
1   643	0362  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y
1   644	0365  8A 45 05						     mov  al, di[5]		     ; AL = vertical   sym
1   645	0368  8A 75 02						     mov  dh, di[2]		     ; DH = right top  sym
1   646	036B  8A 55 03						     mov  dl, di[3]		     ; DL = right down sym
1   647	036E  E8 FF22						     call PrintVrtLine
1   648
1   649								     ; FILL BOX
1   650
1   651	0371  53						     push bx				     ; push (10)
1   652	0372  51						     push cx				     ; push (11)
1   653	0373  8A 3C						     mov  bh, si[X_Num]		     ; BH = X +	1
1   654	0375  80 C7 01						     add  bh, 1
1   655	0378  8A 5C 01						     mov  bl, si[Y_Num]		     ; BL = Y +	1
1   656	037B  80 C3 01						     add  bl, 1
1   657	037E  8A 45 08						     mov  al, di[8]		     ; AL = filling sym
1   658	0381  80 ED 02						     sub  ch, 2				     ; WIDTH  -= 2
1   659	0384  80 E9 02						     sub  cl, 2				     ; HEIGHT -= 2
1   660	0387  E8 FE4D						     call FillScreen
1   661	038A  59						     pop  cx				     ; pop  (11)
1   662	038B  5B						     pop  bx				     ; pop  (10)
1   663
1   664	038C  5B						     pop  bx				     ; pop  (9)	<> pop (X; Y)
1   665	038D  58						     pop  ax				     ; pop  (8)	<> pop STR  +
    666				     ADDR
1   667
1   668								     ; PRINT STR
1   669
1   670	038E  8B C8						     mov  cx, ax			     ; CX = STR	ADDR
1   671	0390  8B D8						     mov  bx, ax			     ; BX = STR	ADDR
1   672	0392  E8 012C						     call StrLen			     ; AX = len	of str
1   673	0395  F7 D8						     neg  ax				     ; AX = ( WIDTH - LEN ) +
    674				     / 2
1   675	0397  33 D2						     xor  dx, dx
1   676	0399  8A 54 02						     mov  dl, si[W_Num]
1   677	039C  03 C2						     add  ax, dx
1   678	039E  33 D2						     xor  dx, dx
1   679	03A0  BF 0002						     mov  di, 2d
1   680	03A3  F7 F7						     div  di
1   681	03A5  8A 3C						     mov  bh, si[X_Num]		     ; X += AL
1   682	03A7  02 F8						     add  bh, al
1   683	03A9  33 C0						     xor  ax, ax			     ; AX = HEIGHT / 2
1   684	03AB  8A 44 03						     mov  al, si[H_Num]
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 13
chg_resd.asm



1   685	03AE  33 D2						     xor  dx, dx
1   686	03B0  BF 0002						     mov  di, 2d
1   687	03B3  F7 F7						     div  di
1   688	03B5  8A 5C 01						     mov  bl, si[Y_Num]		     ; Y += AL
1   689	03B8  02 D8						     add  bl, al
1   690	03BA  8A 64 04						     mov  ah, si[Clr_Num]    ; AH = color
1   691	03BD  E8 FE70						     call PrintStr
1   692
1   693	03C0  5F						     pop di				     ; pop  (7)
1   694	03C1  5F						     pop di				     ; pop  (6)
1   695	03C2  5E						     pop si				     ; pop  (5)
1   696	03C3  5A						     pop dx				     ; pop  (4)
1   697	03C4  59						     pop cx				     ; pop  (3)
1   698	03C5  5B						     pop bx				     ; pop  (2)
1   699	03C6  58						     pop ax				     ; pop  (1)
1   700
1   701	03C7  C3						     ret
1   702	03C8							     endp
1   703
1   704				     ;------------------------------------------------
1   705				     ;	     ANIMATE BOX
1   706				     ;------------------------------------------------
1   707				     ; ENTRY:	     AX	= STR  ADDR
1   708				     ;			     BX	= DATA ADDR
1   709				     ; EXIT:	     NONE
1   710				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1   711				     ; DESTROYS:     NONE
1   712				     ;------------------------------------------------
1   713
1   714	03C8  00		     EmptyStr db	     0
1   715	03C9  14*(00)		     BoxData  db     20	dup (0)
1   716
1   717	03DD			     AnimBox		     proc
1   718
1   719	03DD  53						     push bx		     ; push (1)
1   720	03DE  51						     push cx		     ; push (2)
1   721	03DF  52						     push dx		     ; push (3)
1   722
1   723	03E0  8B CB						     mov  cx, bx
1   724	03E2  BB 03C9r						     mov  bx, offset BoxData
1   725	03E5  BA 0014						     mov  dx, 20d
1   726	03E8  E8 0130						     call memcpy
1   727
1   728	03EB  33 C9						     xor  cx, cx	     ; i = 0
1   729
1   730	03ED  8A 36 03CBr					     mov  dh, BoxData[W_Num]
1   731	03F1  8A 16 03CCr					     mov  dl, BoxData[H_Num]
1   732
1   733	03F5  C6 06 03CBr 03					     mov  BoxData[W_Num], 3d
1   734	03FA  C6 06 03CCr 03					     mov  BoxData[H_Num], 3d
1   735
1   736	03FF  50						     push ax		     ; push (4)
1   737	0400  B8 03C8r						     mov  ax, offset EmptyStr
1   738
1   739	0403  E8 FEF7						     __Next:		     call PrintBox
1   740
1   741	0406  38 36 03CBr									     cmp byte ptr BoxData[W_Num], dh+
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 14
chg_resd.asm



    742				     ; if( CURR_WIDTH == WIDTH )
1   743	040A  74 04										     je	__NoIncW
1   744	040C  FE 06 03CBr									     inc BoxData[W_Num]
1   745
1   746	0410											     __NoIncW:
1   747
1   748	0410  38 16 03CCr									     cmp byte ptr BoxData[H_Num], dl+
    749				     ; if( CURR_HEIGHT == HEIGHT )
1   750	0414  74 04										     je	__NoIncH
1   751	0416  FE 06 03CCr									     inc BoxData[H_Num]
1   752
1   753	041A											     __NoIncH:
1   754
1   755	041A  41										     inc cx			    +
    756				     ; i++
1   757
1   758	041B  83 F9 11										     cmp cx, 17d
1   759	041E  74 0D										     je	__End
1   760
1   761	0420  50										     push ax			    +
    762				     ; push (5)
1   763	0421  51										     push cx			    +
    764				     ; push (6)
1   765	0422  B4 86										     mov  ah, 86h
1   766	0424  B9 0001										     mov  cx, 1d
1   767	0427  CD 15										     int  15h
1   768	0429  59										     pop  cx			    +
    769				     ; pop  (6)
1   770	042A  58										     pop  ax			    +
    771				     ; pop  (5)
1   772
1   773	042B  EB D6										     jmp __Next
1   774
1   775	042D							     __End:
1   776	042D  58						     pop ax		     ; pop  (4)
1   777
1   778	042E  88 36 03CBr					     mov BoxData[W_Num], dh
1   779	0432  88 16 03CCr					     mov BoxData[H_Num], dl
1   780
1   781	0436  E8 FEC4						     call PrintBox
1   782
1   783	0439  5A						     pop dx		     ; pop  (3)
1   784	043A  59						     pop cx		     ; pop  (2)
1   785	043B  5B						     pop bx		     ; pop  (1)
1   786
1   787	043C  C3						     ret
1   788	043D							     endp
1   789
1   790				     ;------------------------------------------------
1   791				     ;	     INPUT STR
1   792				     ;------------------------------------------------
1   793				     ; ENTRY:	     NONE
1   794				     ; EXIT:	     AX	= STR LEN
1   795				     ; DESTROYS:     AX
1   796				     ;------------------------------------------------
1   797
1   798	      =0064		     InputLen =	100
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 15
chg_resd.asm



1   799	043D  64*(00)		     InputStr db     InputLen dup (0)
1   800
1   801	04A1			     Input		     proc
1   802
1   803	04A1  52						     push dx		     ; push (1)
1   804	04A2  33 D2						     xor  dx, dx	     ; i = 0
1   805
1   806	04A4  B4 01						     __Next:		     mov ah, 01h			    +
    807				     ; input char
1   808	04A6  CD 21										     int 21h
1   809
1   810	04A8  56										     push si			    +
    811				     ; push (2)
1   812
1   813	04A9  33 F6										     xor si, si			    +
    814				     ; SI = 0
1   815
1   816	04AB  BE 043Dr										     mov si, offset InputStr	    +
    817				     ; SI = InputStr + DX
1   818	04AE  03 F2										     add si, dx
1   819
1   820	04B0  88 04										     mov [si], al
1   821
1   822	04B2  5E										     pop si			    +
    823				     ; pop  (2)
1   824
1   825	04B3  3C 0D										     cmp al, 13d		    +
    826				     ; if( al == '\r' )
1   827	04B5  74 06										     je	__End
1   828
1   829	04B7  42										     inc dx			    +
    830				     ; i++
1   831	04B8  83 FA 64										     cmp dx, InputLen		    +
    832				     ; if( i ==	InputLen )
1   833	04BB  75 E7										     jne __Next
1   834
1   835	04BD							     __End:
1   836
1   837	04BD  8B C2						     mov ax, dx
1   838	04BF  5A						     pop dx		     ; pop  (1)
1   839
1   840	04C0  C3						     ret
1   841	04C1							     endp
1   842
1   843				     ;------------------------------------------------
1   844
    845				     include	     STR_HNDL.ASM    ; Str handler
1   846
1   847				     ;------------------------------------------------
1   848				     ;	     GET STR LEN
1   849				     ;------------------------------------------------
1   850				     ; ENTRY:	     BX	= STR ADDR
1   851				     ; EXIT:	     AX	= LEN
1   852				     ; EXPECTS:	 END SYM = '\0'
1   853				     ; DESTROYS: AX
1   854				     ;------------------------------------------------
1   855
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 16
chg_resd.asm



1   856	04C1			     StrLen	     proc
1   857
1   858	04C1  33 C0				     xor ax, ax	     ; i = 0
1   859
1   860	04C3  51 56						     push cx si		     ; push (1)	(2)
1   861
1   862	04C5  8B F3				     __Next:		     mov  si, bx     ; SI = BX + i
1   863	04C7  03 F0										 add  si, ax
1   864
1   865	04C9  40										     inc  ax		     ; i++
1   866	04CA  8B 0C										     mov  cx, [si]   ; CX = current +
    867				     symbol
1   868
1   869	04CC  80 FD 00										     cmp  ch, 0d     ; if( ch ==    +
    870				     '\0' )
1   871	04CF  74 02										     je	__End
1   872
1   873	04D1  EB F2										     jmp __Next
1   874
1   875	04D3							     __End:
1   876	04D3  5E 59						     pop si cx		     ; pop  (2)	(1)
1   877
1   878	04D5  C3				     ret
1   879	04D6					     endp
1   880
1   881				     ;------------------------------------------------
1   882				     ;	     GET ADDR OF CHR IN	ARR
1   883				     ;	     RET NULL IF NOT FOUND
1   884				     ;------------------------------------------------
1   885				     ; ENTRY:	     BX	= ARR ADDR
1   886				     ;			     CL	= CHR
1   887				     ;			     DX	= LEN OF THE COMPARED PART (IN BYTES)
1   888				     ; EXIT:	     AX	= ADDR OF CHR
1   889				     ; DESTROYS: AX
1   890				     ;------------------------------------------------
1   891
1   892	04D6			     MemChr		     proc
1   893
1   894	04D6  56						     push si		     ; push (1)
1   895
1   896	04D7  33 C0						     xor ax, ax		     ; AX = NULL
1   897	04D9  33 F6						     xor si, si		     ; i  = 0
1   898
1   899	04DB  83 FA 00						     cmp dx, 0d		     ; if( len == 0 )
1   900	04DE  74 0F						     je	__End
1   901
1   902	04E0  38 08						     __Next:		     cmp bx[si], cl	     ; if( Addr[i]  +
    903				     ==	CHR )
1   904	04E2  74 07										     je	__Found
1   905
1   906	04E4  46										     inc si
1   907
1   908	04E5  3B F2										     cmp si, dx
1   909	04E7  74 06										     je	__End
1   910
1   911	04E9  EB F5										     jmp __Next
1   912
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 17
chg_resd.asm



1   913	04EB  8B C3						     __Found:		     mov ax, bx			     ; AX = +
    914				     ArrAddr + i
1   915	04ED  03 C6										     add ax, si
1   916
1   917	04EF							     __End:
1   918	04EF  5E						     pop si		     ; pop  (1)
1   919
1   920	04F0  C3						     ret
1   921	04F1							     endp
1   922
1   923				     ;------------------------------------------------
1   924				     ;	     GET ADDR OF CHR IN	STR
1   925				     ;	     RET NULL IF NOT FOUND
1   926				     ;------------------------------------------------
1   927				     ; ENTRY:	     BX	= ARR ADDR
1   928				     ;			     CL	= CHR
1   929				     ; EXIT:	     AX	= ADDR OF CHR
1   930				     ; EXPECTS:	 END SYM = '\0'
1   931				     ; DESTROYS: AX
1   932				     ;------------------------------------------------
1   933
1   934	04F1			     StrChr		     proc
1   935
1   936	04F1  56						     push si		     ; push (1)
1   937
1   938	04F2  33 C0						     xor ax, ax		     ; AX = NULL
1   939	04F4  33 F6						     xor si, si		     ; i  = 0
1   940
1   941	04F6  38 08						     __Next:		     cmp byte ptr bx[si], cl	     ; if(  +
    942				     Addr[i] ==	CHR )
1   943	04F8  74 08										     je	__Found
1   944	04FA  80 38 00										     cmp byte ptr bx[si], 0d	    +
    945				     ; if( Addr[i] == '\0' )
1   946	04FD  74 07										     je	__End
1   947
1   948	04FF  46										     inc si
1   949
1   950	0500  EB F4										     jmp __Next
1   951
1   952	0502  8B C3						     __Found:		     mov ax, bx				    +
    953				     ; AX = ArrAddr + i
1   954	0504  03 C6										     add ax, si
1   955
1   956	0506							     __End:
1   957	0506  5E						     pop si		     ; pop  (1)
1   958
1   959	0507  C3						     ret
1   960	0508							     endp
1   961
1   962				     ;------------------------------------------------
1   963				     ;	     THE MEMSET	FUNCTION FILLS
1   964				     ;	     THE FIRST N BYTES OF THE MEMORY
1   965				     ;	     LOCATION POINTED TO BY THE
1   966				     ;	     DESTINATION ARGUMENT WITH THE
1   967				     ;	     CHARACTER SPECIFIED BY THE	CHR ARGUMENT
1   968				     ;------------------------------------------------
1   969				     ; ENTRY:	     BX	= DESTINATION
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 18
chg_resd.asm



1   970				     ;			     CL	= CHR
1   971				     ;			     DX	= N
1   972				     ; EXIT:	     NONE
1   973				     ; DESTROYS: NONE
1   974				     ;------------------------------------------------
1   975
1   976	0508			     MemSet		     proc
1   977
1   978	0508  56						     push si		     ; push (1)
1   979
1   980	0509  33 F6						     xor si, si		     ; i = 0
1   981
1   982	050B  83 FA 00						     cmp dx, 0d		     ; if( N ==	0 )
1   983	050E  74 09						     je	__End
1   984
1   985	0510  88 08						     __Next:		     mov byte ptr bx[si], cl	     ; BX[i]+
    986				     = CHR
1   987
1   988	0512  46										     inc si			    +
    989				     ; i++
1   990
1   991	0513  3B F2										     cmp si, dx			    +
    992				     ; if( i ==	N )
1   993	0515  74 02										     je	__End
1   994
1   995	0517  EB F7										     jmp __Next
1   996	0519							     __End:
1   997	0519  5E						     pop     si			     ; pop  (1)
1   998
1   999	051A  C3						     ret
1  1000	051B							     endp
1  1001
1  1002				     ;------------------------------------------------
1  1003				     ;	     THE MEMCPY	FUNCTION COPIES	N BYTES
1  1004				     ;	     FROM THE ARRAY (SOURCE) TO	THE ARRAY
1  1005				     ;	     (DESTINATION). IF THE ARRAYS OVERLAP,
1  1006				     ;	     THE RESULT	OF THE COPY WILL BE UNDEFINED
1  1007				     ;------------------------------------------------
1  1008				     ; ENTRY:	     BX	= DESTINATION
1  1009				     ;			     CX	= SOURCE
1  1010				     ;			     DX	= N
1  1011				     ; EXIT:	     NONE
1  1012				     ; DESTROYS: NONE
1  1013				     ;------------------------------------------------
1  1014
1  1015	051B			     MemCpy		     proc
1  1016
1  1017	051B  56 55						     push si bp		     ; push (1)	(2)
1  1018
1  1019	051D  8B E9						     mov bp, cx		     ; BP = CX
1  1020
1  1021	051F  33 F6						     xor si, si		     ; i = 0
1  1022
1  1023	0521  83 FA 00						     cmp dx, 0		     ; if( N ==	0 )
1  1024	0524  74 0D						     je	__End
1  1025
1  1026	0526  52						     __Next:		     push dx				    +
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 19
chg_resd.asm



   1027				     ; push (3)
1  1028	0527  8A 12										     mov  dl, bp[si]
1  1029	0529  88 10										     mov  byte ptr bx[si], dl	    +
   1030				     ; BX[i] = CX[i]
1  1031	052B  5A										     pop  dx			    +
   1032				     ; pop  (3)
1  1033
1  1034	052C  46										     inc si			    +
   1035				     ; i++
1  1036
1  1037	052D  3B F2										     cmp si, dx			    +
   1038				     ; if( N ==	i )
1  1039	052F  74 02										     je	__End
1  1040
1  1041	0531  EB F3										     jmp __Next
1  1042
1  1043	0533							     __End:
1  1044	0533  5D 5E						     pop bp si		     ; pop  (2)	(1)
1  1045
1  1046	0535  C3						     ret
1  1047	0536							     endp
1  1048
1  1049				     ;------------------------------------------------
1  1050				     ;	     THE STRCPY	FUNCTION COPIES	THE DATA FROM
1  1051				     ;	     THE SOURCE	ARGUMENT TO THE	DESTINATION
1  1052				     ;	     UNTIL THE END-OF-LINE( NULL ) CHARACTER
1  1053				     ;	     IS	ENCOUNTERED.
1  1054				     ;	     COPYING IS	DONE ALONG WITH	THE
1  1055				     ;	     END-OF-LINE CHARACTER
1  1056				     ;------------------------------------------------
1  1057				     ; ENTRY:	     BX	= DESTINATION
1  1058				     ;			     CX	= SOURCE
1  1059				     ; EXIT:	     NONE
1  1060				     ; DESTROYS: NONE
1  1061				     ;------------------------------------------------
1  1062
1  1063	0536			     StrCpy		     proc
1  1064
1  1065	0536  52 56 55						     push dx si	bp   ; push (1)	(2) (3)
1  1066
1  1067	0539  8B E9						     mov bp, cx		     ; BP = CX
1  1068
1  1069	053B  33 F6						     xor si, si		     ; i = 0
1  1070
1  1071	053D  8A 12						     __Next:		     mov dl, bp[si]
1  1072	053F  88 10										     mov byte ptr bx[si], dl	    +
   1073				     ; BX[i] = CX[i]
1  1074
1  1075	0541  80 3A 00										     cmp byte ptr bp[si], 0d	    +
   1076				     ; if( CX[i] == 0 )
1  1077	0544  74 03										     je	__End
1  1078
1  1079	0546  46										     inc si			    +
   1080				     ; i++
1  1081
1  1082	0547  EB F4										     jmp __Next
1  1083
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 20
chg_resd.asm



1  1084	0549							     __End:
1  1085	0549  5D 5E 5A						     pop bp si dx    ; pop  (3)	(2) (1)
1  1086
1  1087	054C  C3						     ret
1  1088	054D							     endp
1  1089
1  1090				     ;------------------------------------------------
1  1091				     ;	     THE MEMCMP	FUNCTION COMPARES, BYTE	BY BYTE,
1  1092				     ;	     THE TWO ARRAYS ARR_1 AND ARR_2.
1  1093				     ;	     THE COMPARISON CONTINUES UNTIL N BYTES
1  1094				     ;	     HAVE BEEN CHECKED OR UNTIL	DIFFERENT
1  1095				     ;	     BYTES ARE ENCOUNTERED.
1  1096				     ;------------------------------------------------
1  1097				     ; ENTRY:	     BX	= ARR_1
1  1098				     ;			     CX	= ARR_2
1  1099				     ;			     DX	= N
1  1100				     ; EXIT:	     AX	= 0 ( ARR_1[i] == ARR_2[i] : FOR i in [0; N-1] )
1  1101				     ;			     AX	> 0 ( ARR_1[i] >  ARR_2[i] )
1  1102				     ;			     AX	< 0 ( ARR_1[i] <  ARR_2[i] )
1  1103				     ; DESTROYS: AX
1  1104				     ;------------------------------------------------
1  1105
1  1106	054D			     MemCmp		     proc
1  1107
1  1108	054D  56 55						     push si bp		     ; push (1)	(2)
1  1109
1  1110	054F  8B E9						     mov bp, cx		     ; BP = CX
1  1111
1  1112	0551  33 F6						     xor si, si		     ; i  = 0
1  1113
1  1114	0553  83 FA 00						     cmp dx, 0d		     ; if( N ==	0 )
1  1115	0556  74 18						     je	__End
1  1116
1  1117	0558  33 C0						     __Next:		     xor  ax, ax			    +
   1118				     ; AX  = 0
1  1119	055A  8A 00										     mov  al, bx[si]		    +
   1120				     ; AL  = BX[i]
1  1121	055C  52										     push dx			    +
   1122				     ; push (3)
1  1123	055D  33 D2										     xor  dx, dx		    +
   1124				     ; DX = 0
1  1125	055F  8A 12										     mov  dl, bp[si]
1  1126	0561  2B C2										     sub  ax, dx		    +
   1127				     ; AX -= CX[i]
1  1128	0563  5A										     pop  dx			    +
   1129				     ; pop  (3)
1  1130
1  1131	0564  3D 0000										     cmp ax, 0d			    +
   1132				     ; if( AX != 0 )
1  1133	0567  75 07										     jne __End
1  1134
1  1135	0569  46										     inc si
1  1136
1  1137	056A  3B F2										     cmp si, dx			    +
   1138				     ; if( i ==	N )
1  1139	056C  74 02										     je	__End
1  1140
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 21
chg_resd.asm



1  1141	056E  EB E8										     jmp __Next
1  1142	0570							     __End:
1  1143	0570  5D 5E						     pop bp si		     ; pop  (2)	(1)
1  1144
1  1145	0572  C3						     ret
1  1146	0573							     endp
1  1147
1  1148				     ;------------------------------------------------
1  1149				     ;	     THE MEMCMP	FUNCTION COMPARES, BYTE	BY BYTE,
1  1150				     ;	     THE TWO STRINGS STR_1 AND STR_2.
1  1151				     ;	     THE COMPARISON CONTINUES UNTIL THE
1  1152				     ;	     END-OF-LINE( NULL ) OR UNTIL DIFFERENT
1  1153				     ;	     BYTES ARE ENCOUNTERED.
1  1154				     ;------------------------------------------------
1  1155				     ; ENTRY:	     BX	= STR_1
1  1156				     ;			     CX	= STR_2
1  1157				     ; EXIT:	     AX	= 0 ( STR_1[i] == STR_2[i] : FOR ALL i )
1  1158				     ;			     AX	> 0 ( STR_1[i] >  STR_2[i] )
1  1159				     ;			     AX	< 0 ( STR_1[i] <  STR_2[i] )
1  1160				     ; DESTROYS: AX
1  1161				     ;------------------------------------------------
1  1162
1  1163	0573			     StrCmp		     proc
1  1164
1  1165	0573  56 55						     push si bp		     ; push (1)	(2)
1  1166
1  1167	0575  8B E9						     mov bp, cx		     ; BP = CX
1  1168
1  1169	0577  33 F6						     xor si, si		     ; i  = 0
1  1170
1  1171	0579  33 C0						     __Next:		     xor  ax, ax			    +
   1172				     ; AX  = 0
1  1173	057B  8A 00										     mov  al, bx[si]		    +
   1174				     ; AL  = BX[i]
1  1175	057D  52										     push dx			    +
   1176				     ; push (3)
1  1177	057E  33 D2										     xor  dx, dx		    +
   1178				     ; DX = 0
1  1179	0580  8A 12										     mov  dl, bp[si]
1  1180	0582  2B C2										     sub  ax, dx		    +
   1181				     ; AX -= CX[i]
1  1182	0584  5A										     pop  dx			    +
   1183				     ; pop  (3)
1  1184
1  1185	0585  3D 0000										     cmp ax, 0d			    +
   1186				     ; if( AX != 0 )
1  1187	0588  75 08										     jne __End
1  1188
1  1189	058A  80 38 00										     cmp byte ptr bx[si], 0d	    +
   1190				     ; if( BX[i] == 0 )
1  1191	058D  74 03										     je	__End
1  1192
1  1193	058F  46										     inc si
1  1194
1  1195	0590  EB E7										     jmp __Next
1  1196	0592							     __End:
1  1197	0592  5D 5E						     pop bp si		     ; pop  (2)	(1)
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 22
chg_resd.asm



1  1198
1  1199	0594  C3						     ret
1  1200	0595							     endp
1  1201
1  1202				     ;------------------------------------------------
1  1203				     ;	     TRANSLATE STR TO NUMBER
1  1204				     ;------------------------------------------------
1  1205				     ; ENTRY:	     BX	= STR ADDR
1  1206				     ; EXIT:	     AX	= NUM
1  1207				     ; EXPECTS:	     CX	= STR LEN
1  1208				     ; DESTROYS:     AX
1  1209				     ;------------------------------------------------
1  1210
1  1211	0595			     Atoi		     proc
1  1212
1  1213	0595  33 C0						     xor ax, ax		     ; AX = 0
1  1214
1  1215	0597  52 56						     push dx si		     ; push (1)	(2)
1  1216
1  1217	0599  33 D2						     xor dx, dx		     ; i = 0
1  1218
1  1219	059B  8B F3						     __Next:		     mov si, bx		     ; SI = BX +    +
   1220				     STR_LEN - i
1  1221	059D  03 F1										     add si, cx
1  1222	059F  2B F2										     sub si, dx
1  1223	05A1  83 EE 01										     sub si, 1
1  1224
1  1225	05A4  51										     push cx		     ; push +
   1226				     (3)
1  1227
1  1228	05A5  50										     push ax		     ; push +
   1229				     (4)
1  1230	05A6  33 C0										     xor  ax, ax     ; AX = 0
1  1231	05A8  8A 04										     mov  al, [si]   ; AX = [SI] -  +
   1232				     '0'
1  1233	05AA  2C 30										     sub  al, 48d
1  1234
1  1235	05AC  52										     push dx		     ; push +
   1236				     (5)
1  1237	05AD  8B CA										     mov  cx, dx	     ; AX = +
   1238				     AX	* 10^DX
1  1239	05AF  BE 000A										     mov  si, 10d
1  1240	05B2  E3 08										     jcxz __NoMul
1  1241
1  1242	05B4  F7 E6										     __Mul:		     mul si
1  1243
1  1244	05B6  49														    +
   1245				     dec cx
1  1246	05B7  83 F9 00														    +
   1247				     cmp cx, 0
1  1248	05BA  75 F8														    +
   1249				     jne __Mul
1  1250
1  1251	05BC											     __NoMul:
1  1252	05BC  5A										     pop  dx		     ; pop  +
   1253				     (5)
1  1254	05BD  8B C8										     mov  cx, ax
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 23
chg_resd.asm



1  1255
1  1256	05BF  58										     pop ax		     ; pop  +
   1257				     (4)
1  1258	05C0  03 C1										     add ax, cx
1  1259	05C2  59										     pop cx		     ; pop  +
   1260				     (3)
1  1261
1  1262	05C3  42										     inc dx		     ; i++
1  1263
1  1264	05C4  3B D1										     cmp dx, cx		     ; if( i+
   1265				     ==	CX )
1  1266	05C6  75 D3										     jne __Next
1  1267
1  1268	05C8  5E 5A						     pop si dx		     ; pop  (2)	(1)
1  1269
1  1270	05CA  C3						     ret
1  1271	05CB							     endp
1  1272
1  1273				     ;------------------------------------------------
   1274				     include	     REG_PRNT.ASM    ; Print AX	in BIN/DEC/HEX
1  1275
1  1276				     ;------------------------------------------------
1  1277				     ;	     PRINT AX IN BIN
1  1278				     ;------------------------------------------------
1  1279				     ; ENTRY:	     AX	= NUM
1  1280				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1281				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1282				     ; EXIT:	     NONE
1  1283				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1284				     ; DESTROYS:     NONE
1  1285				     ;------------------------------------------------
1  1286
1  1287	      =0010		     bin_len = 16d						     ; len of bin str
1  1288
1  1289	05CB			     PrintBin		     proc
1  1290
1  1291	05CB  57						     push di				     ; push (0)
1  1292
1  1293	05CC  50						     push ax				     ; push (1)
1  1294
1  1295	05CD  E8 FC43						     call GetVideoPos		     ; AX = Video position from	(X; +
   1296				     Y)
1  1297	05D0  BF 0020						     mov di, bin_len * 2d    ; i = bin_len * 2 + AX
1  1298	05D3  03 F8						     add di, ax
1  1299	05D5  FD						     std
1  1300
1  1301	05D6  58						     pop  ax				     ; pop  (1)
1  1302
1  1303	05D7  50 52						     push ax dx				     ; push (2)	(3)
1  1304
1  1305	05D9  33 D2						     xor  dx, dx			     ; i = 0
1  1306
1  1307	05DB  D1 E8						     __Next:		     shr ax, 1				    +
   1308				     ; AX /= 2
1  1309
1  1310	05DD  50										     push ax			    +
   1311				     ; push (4)
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 24
chg_resd.asm



1  1312
1  1313	05DE  72 05										     jc	__One
1  1314
1  1315	05E0  B0 30										     __Zero:		     mov al,+
   1316				     '0'		     ; '0'
1  1317	05E2  EB 03 90														    +
   1318				     jmp __End
1  1319
1  1320	05E5  B0 31										     __One:		     mov al,+
   1321				     '1'		     ; '1'
1  1322
1  1323	05E7  B4 70						     __End:		     mov ah, 70h			    +
   1324				     ; black on	white
1  1325
1  1326	05E9  83 EF 02										     sub di, 2			    +
   1327				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1328	05EC  AB										     stosw
1  1329	05ED  83 C7 02										     add di, 2
1  1330
1  1331	05F0  58										     pop ax			    +
   1332				     ; pop (4)
1  1333
1  1334	05F1  42										     inc dx
1  1335
1  1336	05F2  83 FA 10										     cmp dx, bin_len		    +
   1337				     ; if( dx == bin_len )
1  1338	05F5  75 E4										     jne __Next
1  1339
1  1340	05F7  5A 58						     pop dx ax			     ; pop  (3)	(2)
1  1341	05F9  5F						     pop di			     ; pop  (0)
1  1342
1  1343	05FA  C3						     ret
1  1344	05FB							     endp
1  1345
1  1346				     ;------------------------------------------------
1  1347				     ;	     PRINT AX IN HEX
1  1348				     ;------------------------------------------------
1  1349				     ; ENTRY:	     AX	= NUM
1  1350				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1351				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1352				     ; EXIT:	     NONE
1  1353				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1354				     ; DESTROYS:     NONE
1  1355				     ;------------------------------------------------
1  1356
1  1357	      =0004		     hex_len = 4d						     ; len of hex str
1  1358
1  1359	05FB			     PrintHex		     proc
1  1360
1  1361	05FB  57						     push di				     ; push (0)
1  1362
1  1363	05FC  50						     push ax				     ; push (1)
1  1364
1  1365	05FD  E8 FC13						     call GetVideoPos		     ; AX = Video position from	(X; +
   1366				     Y)
1  1367	0600  BF 0008						     mov di, hex_len * 2d    ; i = hex_len * 2 + AX
1  1368	0603  03 F8						     add di, ax
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 25
chg_resd.asm



1  1369	0605  FD						     std
1  1370
1  1371	0606  58						     pop  ax				     ; pop  (1)
1  1372
1  1373	0607  50 51 52						     push ax cx	dx		     ; push (2)	(3) (4)
1  1374
1  1375	060A  33 D2						     xor dx, dx				     ; i = 0
1  1376
1  1377	060C  B9 0000						     __Next:		     mov cx, 0			     ;	    +
   1378				     shifts counter
1  1379
1  1380	060F  52										     push dx			    +
   1381				     ; push (5)
1  1382	0610  BA 0000										     mov  dx, 0			    +
   1383				     ; DX = 0
1  1384
1  1385	0613  D1 E8										     __Shift:		     shr ax,+
   1386				     1		     ; AX /= 2
1  1387
1  1388	0615  73 09														    +
   1389				     jnc __End
1  1390
1  1391	0617  50														    +
   1392				     __One:		     push ax		     ; push (6)
1  1393	0618  B8 0001														    +
   1394				     mov  ax, 1		     ; AX = 0001b
1  1395	061B  D3 E0														    +
   1396				     shl  ax, cl	     ; DX += 2^CX
1  1397	061D  03 D0														    +
   1398				     add  dx, ax
1  1399	061F  58														    +
   1400				     pop      ax		     ; pop  (6)
1  1401
1  1402	0620  41										     __End:		     inc cx +
   1403				     ; shifts counter ++
1  1404	0621  83 F9 04														    +
   1405				     cmp cx, 4d		     ; if( numShifts ==	4 )
1  1406	0624  75 ED														    +
   1407				     jne __Shift
1  1408
1  1409	0626  8B C8										     mov cx, ax			    +
   1410				     ; CX = AX
1  1411
1  1412	0628  83 FA 0A										     cmp dx, 10d		    +
   1413				     ; if( DX >= 10 )
1  1414	062B  7D 08										     jge __Sym
1  1415
1  1416	062D  83 C2 30										     __Digit:		     add dx,+
   1417				     48d	     ; print( DX + '0' )
1  1418	0630  8A C2														    +
   1419				     mov al, dl
1  1420	0632  EB 09 90														    +
   1421				     jmp __Print
1  1422
1  1423	0635  83 EA 0A										     __Sym:		     sub dx,+
   1424				     10		     ; print( DX - 10 +	'A' )
1  1425	0638  83 C2 41														    +
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 26
chg_resd.asm



   1426				     add dx, 65d
1  1427	063B  8A C2														    +
   1428				     mov al, dl
1  1429
1  1430	063D  5A						     __Print:		     pop dx			     ; pop  +
   1431				     (5)
1  1432
1  1433	063E  B4 70										     mov ah, 70h		    +
   1434				     ; black on	white
1  1435
1  1436	0640  83 EF 02										     sub di, 2			    +
   1437				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1438	0643  AB										     stosw
1  1439	0644  83 C7 02										     add di, 2
1  1440
1  1441	0647  8B C1										     mov ax, cx			    +
   1442				     ; AX = CX
1  1443
1  1444	0649  42										     inc dx			    +
   1445				     ; i++
1  1446
1  1447	064A  83 FA 04										     cmp dx, hex_len	     ; if(  +
   1448				     dx	== hex_len )
1  1449	064D  75 BD										     jne __Next
1  1450
1  1451	064F  5A 59 58						     pop dx cx ax		     ; pop  (4)	(3) (2)
1  1452	0652  5F						     pop di				     ; pop  (0)
1  1453
1  1454	0653  C3						     ret
1  1455	0654							     endp
1  1456
1  1457				     ;------------------------------------------------
1  1458				     ;	     PRINT AX IN DEC
1  1459				     ;------------------------------------------------
1  1460				     ; ENTRY:	     AX	= NUM
1  1461				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1462				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1463				     ; EXIT:	     NONE
1  1464				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1465				     ; DESTROYS:     NONE
1  1466				     ;------------------------------------------------
1  1467
1  1468	      =0005		     dec_len = 5d
1  1469
1  1470	0654			     PrintDec		     proc
1  1471
1  1472	0654  57						     push di				     ; pop  (0)
1  1473
1  1474	0655  50						     push ax				     ; push (1)
1  1475
1  1476	0656  E8 FBBA						     call GetVideoPos		     ; AX = Video position from	(X; +
   1477				     Y)
1  1478	0659  BF 000A						     mov di, dec_len * 2d    ; i = dec_len * 2 + AX
1  1479	065C  03 F8						     add di, ax
1  1480	065E  FD						     std
1  1481
1  1482	065F  58						     pop  ax				     ; pop  (1)
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 27
chg_resd.asm



1  1483
1  1484	0660  50 51 52						     push ax cx	dx		     ; push (2)	(3) (4)
1  1485
1  1486	0663  33 D2						     xor dx, dx				     ; i = 0
1  1487	0665  B9 000A						     mov cx, 10d			     ; CX = 10
1  1488
1  1489	0668  52						     __Next:		     push dx			     ; push +
   1490				     (5)
1  1491
1  1492	0669  33 D2										     xor dx, dx			    +
   1493				     ; DX = 0
1  1494
1  1495	066B  F7 F1										     div  cx			    +
   1496				     ; AX /= 10
1  1497
1  1498	066D  50										     push ax			    +
   1499				     ; push (6)
1  1500
1  1501	066E  80 C2 30										     add  dl, 48d	     ; print+
   1502				     ( DL + '0'	)
1  1503	0671  8A C2										     mov  al, dl
1  1504
1  1505	0673  B4 70										     mov  ah, 70h	     ; black+
   1506				     on	white
1  1507
1  1508	0675  83 EF 02										     sub di, 2			    +
   1509				     ; print( ax ) // with 1 sym left( 2 bytes )
1  1510	0678  AB										     stosw
1  1511	0679  83 C7 02										     add di, 2
1  1512
1  1513	067C  58										     pop ax			    +
   1514				     ; pop  (6)
1  1515	067D  5A										     pop dx			    +
   1516				     ; pop  (5)
1  1517
1  1518	067E  42										     inc dx
1  1519
1  1520	067F  83 FA 05										     cmp dx, dec_len	     ; if(  +
   1521				     DX	== dec_len )
1  1522	0682  75 E4										     jne __Next
1  1523
1  1524	0684  5A 59 58						     pop dx cx ax		     ; pop  (4)	(3) (2)
1  1525	0687  5F						     pop di				     ; pop  (0)
1  1526
1  1527	0688  C3						     ret
1  1528	0689							     endp
1  1529
1  1530				     ;------------------------------------------------
1  1531				     ;	     PRINT AX IN BIN/HEX/DEC
1  1532				     ;------------------------------------------------
1  1533				     ; ENTRY:	     AX	= NUM
1  1534				     ;			     BH	= X LEFT CORNER	COORDS [0; 79]
1  1535				     ;			     BL	= Y LEFT CORNER	COORDS [0; 24]
1  1536				     ; EXIT:	     NONE
1  1537				     ; EXPECTS:	     ES	= 0b800h (VIDEO	SEGMENT)
1  1538				     ; DESTROYS:     NONE
1  1539				     ;------------------------------------------------
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 28
chg_resd.asm



1  1540
1  1541	0689			     PrintNum		     proc
1  1542
1  1543	0689  53						     push bx				     ; push (1)
1  1544
1  1545	068A  E8 FF3E						     call PrintBin
1  1546
1  1547	068D  80 C7 11						     add bh, bin_len + 1d    ; X
1  1548	0690  E8 FF68						     call PrintHex
1  1549
1  1550	0693  80 C7 05						     add bh, hex_len + 1d    ; X
1  1551	0696  E8 FFBB						     call PrintDec
1  1552
1  1553	0699  5B						     pop bx				     ; pop  (1)
1  1554
1  1555	069A  C3						     ret
1  1556	069B							     endp
1  1557
1  1558				     ;------------------------------------------------
1  1559
   1560
   1561	069B			     EOP:
   1562
   1563				     end		     Start
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 29
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "03/04/23"
??FILENAME			  Text	 "chg_resd"
??TIME				  Text	 "18:13:23"
??VERSION			  Number 040A
@32BIT				  Text	 0
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0707H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 CHG_RESD
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
ANIMBOX				  Near	 DGROUP:03DD
ATOI				  Near	 DGROUP:0595
BIN_LEN				  Number 0010
BOXDATA				  Byte	 DGROUP:03C9
BOXDATARSD			  Byte	 DGROUP:0149
BOXSTRRSD			  Byte	 DGROUP:0148
CLRSCREEN			  Near	 DGROUP:0205
CLR_NUM				  Number 0004
DEC_LEN				  Number 0005
EMPTYSTR			  Byte	 DGROUP:03C8
EOP				  Near	 DGROUP:069B
FILLSCREEN			  Near	 DGROUP:01D7
GETVIDEOPOS			  Near	 DGROUP:0213
HEX_LEN				  Number 0004
H_NUM				  Number 0003
INPUT				  Near	 DGROUP:04A1
INPUTLEN			  Number 0064
INPUTSTR			  Byte	 DGROUP:043D
ISPRINTREG			  Byte	 DGROUP:014F
MEMCHR				  Near	 DGROUP:04D6
MEMCMP				  Near	 DGROUP:054D
MEMCPY				  Near	 DGROUP:051B
MEMSET				  Near	 DGROUP:0508
NEW08				  Near	 DGROUP:0150
NEW09				  Near	 DGROUP:01A9
OLD_08_OFS			  Word	 DGROUP:01A4
OLD_08_SEG			  Word	 DGROUP:01A6
OLD_09_OFS			  Word	 DGROUP:01D2
OLD_09_SEG			  Word	 DGROUP:01D4
PRINTBIN			  Near	 DGROUP:05CB
PRINTBOX			  Near	 DGROUP:02FD
PRINTCHAR			  Near	 DGROUP:0225
PRINTDEC			  Near	 DGROUP:0654
PRINTHEX			  Near	 DGROUP:05FB
PRINTHRZLINE			  Near	 DGROUP:0256
PRINTNUM			  Near	 DGROUP:0689
PRINTSTR			  Near	 DGROUP:0230
PRINTVRTLINE			  Near	 DGROUP:0293
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 30
Symbol Table



START				  Near	 DGROUP:0100
STRCHR				  Near	 DGROUP:04F1
STRCMP				  Near	 DGROUP:0573
STRCPY				  Near	 DGROUP:0536
STRLEN				  Near	 DGROUP:04C1
TYPE_0				  Byte	 DGROUP:02D0
TYPE_1				  Byte	 DGROUP:02D9
TYPE_2				  Byte	 DGROUP:02E2
TYPE_3				  Byte	 DGROUP:02EB
TYPE_4				  Byte	 DGROUP:02F4
TYPE_NUM			  Number 0005
W_NUM				  Number 0002
X_NUM				  Number 0000
X_POS				  Number 0001
Y_NUM				  Number 0001
__DIGIT				  Near	 DGROUP:062D
__END				  Near	 DGROUP:0198
__END				  Near	 DGROUP:01F3
__END				  Near	 DGROUP:0251
__END				  Near	 DGROUP:0292
__END				  Near	 DGROUP:02CF
__END				  Near	 DGROUP:042D
__END				  Near	 DGROUP:04BD
__END				  Near	 DGROUP:04D3
__END				  Near	 DGROUP:04EF
__END				  Near	 DGROUP:0506
__END				  Near	 DGROUP:0519
__END				  Near	 DGROUP:0533
__END				  Near	 DGROUP:0549
__END				  Near	 DGROUP:0570
__END				  Near	 DGROUP:0592
__END				  Near	 DGROUP:05E7
__END				  Near	 DGROUP:0620
__ENDNEXTLINE			  Near	 DGROUP:0201
__ENDPRINTING			  Near	 DGROUP:028E
__ENDPRINTING			  Near	 DGROUP:02CB
__FOUND				  Near	 DGROUP:04EB
__FOUND				  Near	 DGROUP:0502
__MUL				  Near	 DGROUP:05B4
__NEXT				  Near	 DGROUP:01E4
__NEXT				  Near	 DGROUP:0236
__NEXT				  Near	 DGROUP:0281
__NEXT				  Near	 DGROUP:02BE
__NEXT				  Near	 DGROUP:0403
__NEXT				  Near	 DGROUP:04A4
__NEXT				  Near	 DGROUP:04C5
__NEXT				  Near	 DGROUP:04E0
__NEXT				  Near	 DGROUP:04F6
__NEXT				  Near	 DGROUP:0510
__NEXT				  Near	 DGROUP:0526
__NEXT				  Near	 DGROUP:053D
__NEXT				  Near	 DGROUP:0558
__NEXT				  Near	 DGROUP:0579
__NEXT				  Near	 DGROUP:059B
__NEXT				  Near	 DGROUP:05DB
__NEXT				  Near	 DGROUP:060C
__NEXT				  Near	 DGROUP:0668
Turbo Assembler	 Version 4.1	    03/04/23 18:13:24	    Page 31
Symbol Table



__NEXTLINE			  Near	 DGROUP:01E1
__NOINCH			  Near	 DGROUP:041A
__NOINCW			  Near	 DGROUP:0410
__NOMUL				  Near	 DGROUP:05BC
__NOPRINTREGS			  Near	 DGROUP:01D0
__ONE				  Near	 DGROUP:05E5
__ONE				  Near	 DGROUP:0617
__PRINT				  Near	 DGROUP:063D
__PRINTREGS			  Near	 DGROUP:01B3
__SHIFT				  Near	 DGROUP:0613
__SYM				  Near	 DGROUP:0635
__ZERO				  Near	 DGROUP:05E0

Macro Name

EXIT

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  069B Word	  Public  CODE
